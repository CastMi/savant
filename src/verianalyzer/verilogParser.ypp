%code requires{
//#define yylex verilog::yylex
class VerilogFlexLexer;
class IIR_DesignFileList;
// The %union uses the following
#include <vector>
#include "IRBasicDataTypes.hh"
#include "plugin_class_factory.hh"
/**
  * The verilog parser driver will include this header and therefore
  * it needs this prototype.
  */
void verilog_parse(const std::string& fname, IIR_DesignFileList& res, plugin_class_factory* fac);
}

%{
#include "IIR_DesignFileList.hh"
#include "IIRScram_EntityDeclaration.hh"
#include "IIRScram_LibraryUnit.hh"
#include "IIRScram_Identifier.hh"
#include "symbol_table.hh"

#include "verilogParser.hpp"
#include "verilogLexer.hpp"

#include <string>
#include <list>
#include <cstring>
#include <fstream>

int yylex (VerilogFlexLexer* lexer);
int yyerror (IIR_DesignFileList& ir_verilog, VerilogFlexLexer* lexer, plugin_class_factory* fac, char const *msg);

symbol_table * my_symbol_table;
IIRScram_LibraryUnit * ent = new IIRScram_EntityDeclaration();
IIRScram_LibraryUnit * arc;

%}

/*
 * The following lines result in the signatures
 * int yyparse (plugin_class_factory* fac, VerilogFlexLexer* lexer, IIR_DesignFileList& ir_verilog);
 * int yyerror (IIR_DesignFileList& ir_verilog, VerilogFlexLexer* lexer, plugin_class_factory* fac, char const *msg);
 */
%parse-param {IIR_DesignFileList& ir_verilog}
%parse-param {VerilogFlexLexer* lexer}
%parse-param {plugin_class_factory* fac}


/*
 * The following line results in the signature
 * int yylex (VerilogFlexLexer* lexer);
 */
%lex-param {VerilogFlexLexer* lexer}

%union {
      bool flag;
      char letter;
      int  int_val;
      char* text;
      std::vector<std::string>* strings;
      IIR_Mode direction;
      struct {
         IIR_Mode dir;
         std::string* name;
      } portlist;
};

/* Token with values */
%token <text> IDENTIFIER

/* Token with no values */
%token K_endmodule K_module K_input K_output list_of

/* Non end literals with values */
//%type <strings> list_of_identifiers
//%type <direction> port_direction
//%type <portlist> module_item

%start source_text
%%

  /* IEEE1800-2005: A.1.2 */
  /* source_text ::= [ timeunits_declaration ] { description } */
source_text
   : description_list
   ;

  /* NOTE 1: We pull the "timeunits_declaration" into the description
     here in order to be a little more flexible with where timeunits
     statements may go. This may be a bad idea, but it is legacy now. */
  /* NOTE 2: The "module" rule of the description combines the
     module_declaration, program_declaration, and interface_declaration
     rules from the standard description. */
description /* IEEE1800-2005: A.1.2 */
  : module
  ;

description_list
  : description
  | description_list description
  ;

  /* This is the global structure of a module. A module is a start
     section, with optional ports, then an optional list of module
     items, and finally an end marker. */
module
  : K_module IDENTIFIER
      {
      // return value
      //IIR_Identifier * ident = IIRBase_Identifier::get( $2, strlen($2), fac );
      // entity_declaration
      //ent->set_declarator (ident);
      //dynamic_cast<IIRScram_EntityDeclaration *>(ent)->_add_declaration_and_open_scope();
      }
    '(' list_of_identifiers ')' ';'
      {
      //dynamic_cast<IIRScram_EntityDeclaration *>(ent)->_type_check();
      //my_symbol_table->close_scope(ent);
      // qua dovrei avere il collegamento tra architecture e entity
      }
    module_item_list
    K_endmodule
      {  }
  ;

module_item_list
  : module_item_list module_item
  | module_item
    {
    //$$->push_back($1)
    }
  ;

module_item
  :  port_direction IDENTIFIER ';'
      {
      //$$ = { $1, new std::string($2) };
      }
	;

port_direction
  : K_input 
  {
  //$$ = IIR_IN_MODE; 
  }
  | K_output
  {
  //$$ = IIR_OUT_MODE;
  }
  ;

list_of_identifiers
	: IDENTIFIER
                {
                //$$ = new std::vector<std::string>{$1};
                }
	| list_of_identifiers ',' IDENTIFIER
                {
                //$$->push_back($3);
                }
	;

%%

void verilog_parse(const std::string & fname, IIR_DesignFileList& res, plugin_class_factory* fac)
{
   std::ifstream is(fname.c_str());
   VerilogFlexLexer *lexer = new VerilogFlexLexer(is);
   yyparse (res, lexer, fac);
}

int yylex (VerilogFlexLexer* lexer)
{
   //lexer->lvalp = lvalp;
   return lexer->yylex();
}

int yyerror (IIR_DesignFileList& ir_verilog, VerilogFlexLexer* lexer, plugin_class_factory* fac, char const *msg)
{
   abort();
}
