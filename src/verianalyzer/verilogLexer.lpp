/**
 * @author Michele Castellana <michele.castellana@mail.polimi.it>
 */


/* 
 * Makes the scanner not call `yywrap()' upon an
 * end-of-file, but simply assume that there are
 * no more files to scan.
 */
%option noyywrap

/* 
 * Causes the default rule (that unmatched scanner
 * input is echoed to stdout) to be suppressed.
 * If the scanner encounters input that does not
 * match any of its rules, it aborts with an error.
 * This option is useful for finding holes in a
 * scanner's rule set.
 */
%option nodefault

/*
 * Instructs flex to generate an 8-bit scanner,
 * i.e., one which can recognize 8-bit characters.
 */
%option 8bit

/*
 * Instructs flex to generate a batch scanner.
 * In general, you use it when you are certain that
 * your scanner will never be used interactively, and
 * you want to squeeze a little more performance out
 * of it.
 */
%option batch

/*
 * Instructs flex to generate a scanner which never
 * considers its input interactive.
 */
%option never-interactive
%option warn
/*
 * Directs flex to generate a scanner that maintains
 * the number of the current line read from its input
 * in the global variable yylineno
 */
%option yylineno
%option debug
%option prefix="ss"

%{

#include <iostream>
#include <fstream>
#include <stdint.h>
#include <inttypes.h>
#include <set>
#include <string>
#include <vector>
#include <list>

#undef YY_DECL
#define YY_DECL int VerilogFlexLexer::yylex()
#include "verilogParser.hpp"
#include "verilogLexer.hpp"
int yyFlexLexer::yywrap() { return 1; };
int yyFlexLexer::yylex()
	{
	return 0;
	};
%}

/*=========================================================================
                          TOKEN DEFINITIONS
=========================================================================*/

ID          [a-zA-Z_0-9]*

%%

%"input" { LexerError("Lex err"); return K_input; }
%"output" { LexerError("Lex err"); return K_input; }
%"endmodule" { LexerError("Lex err"); return K_endmodule; }
%"module" { LexerError("Lex err"); return K_module; }
[ \t\r\n]+      { LexerError("sdfsfd"); }
{ID}            { LexerError("Lex err"); lvalp->text = strdup(YYText()); return IDENTIFIER; }
.               { LexerError("Lexical Error"); }

%%
