
// Copyright (c) The University of Cincinnati.  All rights reserved.

// UC MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
// SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
// OR NON-INFRINGEMENT.  UC SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY
// LICENSEE AS A RESULT OF USING, RESULT OF USING, MODIFYING OR
// DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.

// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the U.S.,
// and the terms of this license.

// You may modify, distribute, and use the software contained in this
// package under the terms of the "GNU LIBRARY GENERAL PUBLIC LICENSE"
// version 2, June 1991. A copy of this license agreement can be found in
// the file "LGPL", distributed with this archive.

#header <<

#ifndef SCRAM_HEADER_DEFS
#define SCRAM_HEADER_DEFS

#include <FlexLexer.h>
#include "vhdl.hh"
#include "VHDLToken.hh"
#include "ATokPtr.h"
#include "error_func.hh"
#include "resolution_func.hh"
#include "set.hh"
#include "scram.hh"
#include "stack.hh"
#include "StandardPackage.hh"
#include "language_processing_control.hh"
#include "plugin_class_factory.hh"
#include "library_manager.hh"
#include "IIRScram_IncompleteTypeDefinition.hh"

#include <sstream>
using std::ostringstream;

enum InterfaceListObjectType {
  ILOT_UNSPECIFIED,
  ILOT_FILE,
  ILOT_CONSTANT,
  ILOT_VARIABLE,
  ILOT_SIGNAL,
  ILOT_TERMINAL,
  ILOT_QUANTITY
};

struct scram_binding_info_t {
  IIRScram_LibraryUnit       *entity_aspect;
  IIRScram_AssociationList   *generic_map_aspect;
  IIRScram_AssociationList   *port_map_aspect;

  // why not have self initializing structs?
  scram_binding_info_t(){
    entity_aspect       = NULL;
    generic_map_aspect  = NULL;
    port_map_aspect     = NULL;
  }
};

#endif
>>

<<
#include "VHDLLexer.hh"
#include "symbol_table.hh"
#include "scram_func.hh"

symbol_table *cgen_sym_tab_ptr;	// pointer to process symbol table, for publish_cc declarations
symbol_table *cgen_arch_sym_tab_ptr;

// Capture comments in a design file if the capture_comments flag is true.
// The global variable design_file_comment_list will be used to capture
// comments in the lexer. 
extern bool *capture_comments;
IIRScram_CommentList *design_file_comment_list = NULL;

bool need_to_write_libraries;
extern bool debug_symbol_table;
extern language_processing_control *lang_proc;
stack<IIRScram_SequentialStatement> loop_statements;
>>

/* **********************************************************************

scanner declarations

********************************************************************** */

/* terminal symbols */

#token AMPERSAND
#token QUOTE
#token L_PAREN
#token R_PAREN
#token L_BRACKET
#token R_BRACKET
#token COMMA

#token COLON_EQUAL
#token COLON
#token SEMI_COLON
#token LESS_GREATER
#token LESS_EQUAL
#token LESS
#token EQUAL_GREATER
#token EQUAL
#token GREATER_EQUAL
#token GREATER
#token CHOICE1
#token CHOICE2
#token NOT_EQUAL
#token DOT

/* operators */

#token EXPONENT
#token MULTIPLY
#token DIVIDE
#token PLUS
#token MINUS

/* reserved words */

#token ABS
#token ACCESS
#token AFTER
#token ALIAS
#token ALL
#token AND
#token ARCHITECTURE
#token ARRAY
#token ASSERT
#token ATTRIBUTE
#token BEGIN_
#token BLOCK
#token BODY
#token BUFFER
#token BUS
#token CASE
#token COMPONENT
#token CONFIGURATION
#token CONSTANT
#token DISCONNECT
#token DOWNTO
#token ELSE
#token ELSIF
#token END
#token ENTITY
#token EXIT
#token FILE_
#token FOR
#token FUNCTION
#token GENERATE
#token GENERIC
#token GROUP
#token GUARDED
#token IF
#token IMPURE
#token INOUT
#token IN
#token INERTIAL
#token IS
#token LABEL
#token LIBRARY
#token LINKAGE
#token LITERAL
#token LOOP
#token MAP
#token MOD
#token NAND
#token NEW
#token NEXT
#token NOR
#token NOT
#token NULL_
#token OF
#token ON
#token OPEN
#token OR
#token OTHERS
#token OUT
#token PACKAGE_
#token PORT
#token POSTPONED
#token PROCEDURE
#token PROCESS
#token PURE
#token RANGE
#token RECORD
#token REGISTER
#token REJECT_
#token REM
#token REPORT
#token RETURN
#token ROL
#token ROR
#token SELECT
#token SEVERITY
#token SLA
#token SLL
#token SRA
#token SRL
#token SHARED
#token SIGNAL
#token SUBTYPE
#token THEN
#token TO
#token TRANSPORT
#token TYPE
#token UNITS
#token UNTIL
#token UNAFFECTED
#token USE
#token VARIABLE
#token WAIT
#token WHEN
#token WHILE
#token WITH
#token XOR
#token XNOR

// attributes, turned on/off in lexer

#token ACTIVE
#token ASCENDING
#token BASE
#token DELAYED
#token DRIVING_VALUE
#token DRIVING
#token EVENT
#token HIGH
#token IMAGE
#token INSTANCE_NAME
#token LAST_ACTIVE
#token LAST_EVENT
#token LAST_VALUE
#token LEFTOF
#token LEFT
#token LENGTH
#token LOW
#token PATH_NAME
#token POS
#token PRED
#token RIGHTOF
#token RIGHT
#token REVERSE_RANGE
#token SIMPLE_NAME
#token STABLE
#token SUCC
#token TRANSACTION
#token QUIET
#token VALUE
#token VAL

/* Identifiers and literals */

#token BASIC_IDENTIFIER
#token EXTENDED_IDENTIFIER

#token BASED_INTEGER_LITERAL
#token BASED_FLOATING_POINT_LITERAL

#token DECIMAL_INTEGER_LITERAL
#token DECIMAL_FLOATING_POINT_LITERAL

#token STRING_LITERAL
#token BIT_STRING_LITERAL
#token CHARACTER_LITERAL 

// token class definitions

#tokclass CHOICE {CHOICE1 CHOICE2}

#tokclass IDENTIFIER {BASIC_IDENTIFIER EXTENDED_IDENTIFIER}

#tokclass AND_OR_XOR_XNOR {AND OR XOR XNOR}

#tokclass NAND_NOR {NAND NOR}

#tokclass ABS_NOT {ABS NOT}

#tokclass LOGIC_OPERATOR {AND_OR_XOR_XNOR NAND_NOR ABS_NOT}

#tokclass RELATIONAL_OPERATOR {EQUAL NOT_EQUAL LESS LESS_EQUAL GREATER GREATER_EQUAL}

#tokclass SHIFT_OPERATOR {SLL SRL SLA SRA ROL ROR}

#tokclass ADDING_OPERATOR {PLUS MINUS AMPERSAND}

#tokclass MULTIPLYING_OPERATOR {MULTIPLY DIVIDE MOD REM}

#tokclass SIGN_OPERATOR {PLUS MINUS}

#tokclass OPERATOR_SYM {LOGIC_OPERATOR RELATIONAL_OPERATOR SHIFT_OPERATOR ADDING_OPERATOR MULTIPLYING_OPERATOR EXPONENT}

// ****************************************
// additional tokens for VHDL-AMS
// ****************************************

#token ABOVE
#token ACROSS
#token BREAK
#token CONTRIBUTION
#token DOT_
#token EQUAL_EQUAL
#token LIMIT
#token LTF
#token NATURE
#token NOISE
#token PROCEDURAL
#token QUANTITY
#token REFERENCE
#token SPECTRUM
#token SUBNATURE
#token TERMINAL
#token THROUGH
#token TOLERANCE
#token ZTF

// ****************************************
// end token additions for VHDL-AMS
// ****************************************

// ****************************************
// additional tokens for VHDL-2001
// ****************************************

#token PROTECTED

// ****************************************
// end token additions for VHDL-2001
// ****************************************

#token ENDFILE		// end of file token
#token NONE		// indicates no token known

class VHDLParser {

<<
public: 

  ~VHDLParser(){};

  // This method set not only the location of the token but also
  // the design_file_name that will be used by the symbol_table
  // for the scopes.
  void copy_location( ANTLRTokenPtr source, IIR *destination ) {
    ANTLRToken *token = (ANTLRToken *)source.operator->();
    // Remove Scram
    dynamic_cast<IIRScram *>(destination)->set_base_info( dynamic_cast<IIRScram_DesignFile *>(my_design_file), token->getLine(), token->getLineOffset(),
			     token->getFileOffset() );
//     if_node->_set_design_file(  );
//     if_node->set_line_number();
//     if_node->set_column_offset();
//     if_node->set_character_offset();
  }

  void copy_location( IIR *src, IIR *dest) {
    my_design_file->copy_location(src, dest);
  }

  /** panic is the standard total failure procedure for the pccts generated
      parser.  no return from this function occurs.  it's redefined here to
      report a "scram failure" and to tie into our standard error reporting
      facility. */
  void panic( const char *msg ){
    ANTLRToken *tok = (ANTLRToken *)LT(1);
    ostringstream er;
    er << "scram: Panic!!  Internal failure: " << msg;
    report_error(tok, er.str());
    exit(PCCTS_EXIT_FAILURE);
  }
  
  /** syn is the standard error reporting function that the pccts generated
      parser calls to report errors.  it's redefined here to tie into our
      error reporting facilities.
      
      at present the #errclass is not supported properly by antlr in c++
      mode and we find that listing the expected tokens provides more
      confusion than enlightment to our users.  consequently, this function
      only reports that a syntax error exists and at which token the error
      was found. */
  void syn (_ANTLRTokenPtr token, 
	    ANTLRChar *egroup, 
	    SetWordType *eset,
	    ANTLRTokenType etok, 
	    int k) {
    
    ANTLRToken *tok = (ANTLRToken *)LT(1);
    ostringstream er;

    if( tok->getIIRPtr() != NULL ){
      er << "syntax error at |" << *tok->getIIRPtr() << "|";
    }
    else{
      er << "syntax error at |" << tok->getText() << "|";
    }
    report_error(tok, er.str());
  }

  /** these traceXXX functions are debugging methods that will be called by
      the grammar rules when they are entered/exited.  They will be called
      only with the "-gd" switch is given to antlr. */

  
  /* traceOptionValue: zero value turns off tracing for all expansions. */
  /* traceGuessOptionValue: zero value turns off tracing for lookahead (guessing) expansions. */
  
  /* tracein() is called as each production is entered.  Expansions that
     are performing a lookhead have a leading space and "?" character. */
  void tracein(const ANTLRChar *rule) {
    
    int       doIt=0;
    
    traceDepth++;
    //    traceCurrentRuleName=rule;
    
    if (traceOptionValue <= 0) {
      doIt=0;
    } else if (guessing && traceGuessOptionValue <= 0) {
      doIt=0;
    } else {
      doIt=1;
    };
    
    if (doIt) {
      printMessage(stderr,"%s%s\" entering: %s depth %d\n",
		   guessing ? " ?token: \"" : "token:   \"",
		   LT(1)->getType() == eofToken ? "@" : LT(1)->getText(),
		   rule,
		   traceDepth);
    };
  }
  
  /* traceout() is called as each production is exited.  */
  void traceout(const ANTLRChar * rule) {
    
    int       doIt=0;
    
    if (traceOptionValue <= 0) {
      doIt=0;
    } else if (guessing && traceGuessOptionValue <= 0) {
      doIt=0;
    } else {
      doIt=1;
    };
    
    if (doIt) {
      printMessage(stderr,"%s%s\" exiting:  %s depth %d\n",
		   guessing ? " ?token: \"" : "token:   \"",
		   LT(1)->getType() == eofToken ? "@" : LT(1)->getText(),
		   rule,
		   traceDepth);
    };
    traceDepth--;
  }
  
private:
  symbol_table                  *my_symbol_table;
  IIRScram_DesignFile                *my_design_file;
  plugin_class_factory          *my_factory;
  StandardPackage               *my_std_package;
>>

/* **********************************************************************

design units

********************************************************************** */

design_file[ IIRScram_DesignFile                     *file,
             symbol_table                            *sym_tab,
             IIR_LibraryDeclaration                  *new_lib_decl,
             bool                               need_to_write_libraries,
             plugin_class_factory               *factory,
             StandardPackage                    *package
           ]:
  <<
    my_design_file = file;
    my_symbol_table = sym_tab;
    my_factory = factory;
    my_std_package = package;
    ASSERT( new_lib_decl != NULL );
  >>
  ( design_unit[ dynamic_cast<IIRScram_LibraryUnitList *>(file->get_library_units()),
		 new_lib_decl, need_to_write_libraries ] )+ ENDFILE
  <<ASSERT( loop_statements.get_top_of_stack() == 0 );>>
;

design_unit[ IIRScram_LibraryUnitList        *liblist, 
	     IIR_LibraryDeclaration          *library_decl,
	     bool                            need_to_write_libraries ]:
  <<
    IIRScram_LibraryUnit *unit = NULL;
    IIRScram_DeclarationList *context_list = NULL;
  >>
  <<
    context_list = new IIRScram_DeclarationList();
    my_symbol_table->open_scope( library_decl );
  >>
  context_clauses[context_list]
  library_unit[ library_decl ] > [unit]
  <<
    copy_location( unit, liblist );
    copy_location( unit, unit->get_context_items() );
    // Take the temporary context_list, and put the elements into the unit's
    // context_items.
    unit->set_context_items(context_list);

    if( library_decl->get_primary_units()->in_list( library_decl ) == false ){
      library_decl->get_primary_units()->append( unit );
    }

    if( need_to_write_libraries == true && parse_error == false ){
      library_manager::instance()->parse_into_work_dir( unit );
    }

    my_symbol_table->close_scope( library_decl );
    liblist->append(unit);
  >>
;

library_unit[ IIR_LibraryDeclaration *library ] > [IIRScram_LibraryUnit *unit]:
  <<$unit = NULL;>>
  primary_unit[ library ] > [$unit]
| secondary_unit[ library ] > [$unit]
;

primary_unit[ IIR_LibraryDeclaration *library ] > [IIRScram_LibraryUnit *unit]:
  <<$unit = NULL;>>
  entity_declaration > [$unit]
| configuration_declaration[ library ] > [$unit]
| package_declaration > [$unit]
;

secondary_unit[ IIR_LibraryDeclaration *library ] > [IIRScram_LibraryUnit *unit]:
  <<$unit = NULL;>>
  architecture_body[ library ] > [$unit]
| package_body[ library ] > [$unit]
;

library_clause[IIR_DeclarationList *list]:
  LIBRARY logical_library_name_list[$list] SEMI_COLON
;

logical_library_name_list[IIR_DeclarationList *list]:
  <<
    IIRScram_LibraryClause *lib = NULL;
    IIRScram_Identifier *name = NULL;
  >>
  logical_name > [name]
  <<
    lib = new IIRScram_LibraryClause();
    copy_location( name, lib );
    lib->set_logical_name( name );
    dynamic_cast<IIRScram_LibraryClause *>(lib)->_type_check();
    list->append(lib);
  >>
  (
    COMMA logical_name > [name]
    <<
      lib = new IIRScram_LibraryClause();
      copy_location( name, lib );
      lib->set_logical_name( name );
      dynamic_cast<IIRScram_LibraryClause *>(lib)->_type_check();
      list->append(lib);
    >>
  )*
;

logical_name > [IIRScram_Identifier *s]: 
  <<$s = NULL;>>
  identifier > [$s]
;

context_clauses[IIR_DeclarationList *list]:
  (context_item[$list])*
;

context_item[IIR_DeclarationList *list]:
  library_clause[list]
| use_clause[list]
;

/* **********************************************************************

design entities, architectures, and configurations

********************************************************************** */

entity_declaration > [IIRScram_EntityDeclaration *new_entity]:
  <<
    $new_entity = NULL;
    IIRScram_Identifier *entity_designator = NULL;
    IIRScram_SimpleName *end_designator = NULL;
  >>
  entity:ENTITY identifier > [entity_designator] IS
  <<
    $new_entity = new IIRScram_EntityDeclaration();
    $new_entity->set_declarator( entity_designator );
    copy_location( entity, $new_entity );
    dynamic_cast<IIRScram_EntityDeclaration *>($new_entity)->_add_declaration_and_open_scope();
  >>
  entity_header[$new_entity]
  entity_declarative_part[ $new_entity->get_entity_declarative_part() ]
  <<
    copy_location( $new_entity, $new_entity->get_entity_declarative_part() );
    copy_location( $new_entity, $new_entity->get_entity_statement_part() );
  >>
  { 
    BEGIN_ 
    entity_statement_part[$new_entity->get_entity_statement_part()] 
  }
  END { ENTITY } 
  {
    simple_name > [end_designator]
    <<check_name( entity_designator, end_designator, "entity" );>>
  }
  SEMI_COLON
  <<
    dynamic_cast<IIRScram_EntityDeclaration *>($new_entity)->_type_check();
    my_symbol_table->close_scope( $new_entity );
  >>
;

entity_header[IIRScram_EntityDeclaration *entity]:
  { generic_clause[ entity->get_generic_clause() ] }
  { port_clause[ entity->get_port_clause() ]}
;

entity_declarative_part[IIR_DeclarationList *decl_list]:
  ( entity_declarative_item[$decl_list] )*
;

entity_declarative_item[IIR_DeclarationList *decl_list]:
  subprogram[ decl_list ]
| type_declaration[ decl_list ]
| subtype_declaration[ decl_list ]
| constant_declaration[ decl_list ]
| signal_declaration[ decl_list ]
| shared_variable_declaration[ decl_list ]
| file_declaration[ decl_list ]
| alias_declaration[ decl_list ]
| attribute_declarative_item[ decl_list ]
| disconnection_specification[ decl_list ]
| use_clause[ decl_list ]
| (LIMIT | NATURE | SUBNATURE | QUANTITY | TERMINAL)?
  <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
  ( step_limit_specification[ decl_list ]
  | nature_declaration[ decl_list ]
  | subnature_declaration[ decl_list ]
  | quantity_declaration[ decl_list ]
  | terminal_declaration[ decl_list ]
  )
| (GROUP IDENTIFIER COLON)? group_declaration[ decl_list ]
| group_template_declaration[ decl_list ]
;

entity_statement_part[IIR_ArchitectureStatementList *stmt_list]:
  <<IIRScram_ConcurrentStatement *stmt = NULL;>>
  ( entity_statement > [stmt] <<$stmt_list->append(stmt);>> )*
;

entity_statement > [IIRScram_ConcurrentStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram_Label *label = NULL;
    IIR_Boolean postpone = false;
  >>
  { stmt_label > [label] } 
  { POSTPONED <<postpone = true;>> }  
  entity_stmt[ postpone, label ] > [$stmt]
  <<if( label != NULL ){ $stmt->set_label( label ); }>>
;

entity_stmt [ IIR_Boolean postpone, IIRScram_Label *label ] > [IIRScram_ConcurrentStatement *stmt]:
  <<$stmt = NULL;>>
  concurrent_assertion_statement[ label ] > [$stmt]
  <<(dynamic_cast<IIRScram_ConcurrentAssertionStatement*>($stmt))->set_postponed(postpone);>>
| concurrent_procedure_call[ label ] > [$stmt]
  <<(dynamic_cast<IIRScram_ConcurrentProcedureCallStatement*>($stmt))->set_postponed(postpone);>>
| process_statement[ label ] > [$stmt]
  <<(dynamic_cast<IIRScram_ProcessStatement*>($stmt))->set_postponed(postpone);>>
;

concurrent_procedure_call[ IIRScram_Label *label ] > [IIRScram_ConcurrentStatement *s]:
  <<
    $s = NULL;
    IIRScram_Name                                    *temp_name                      = NULL;
    IIRScram_ConcurrentProcedureCallStatement        *proc_call_statement            = NULL;
    IIRScram_ComponentInstantiationStatement         *comp_instantiation_statement   = NULL;

    bool found_procedure = false;
    bool found_component = false;
  >>
  complex_name > [temp_name] SEMI_COLON
  <<
    // This could be a component instantiaion statement too.  We need to
    // figure out which it is.
    savant::set<IIRScram_Declaration*> *procedure_decls = NULL;
    if( temp_name->get_kind() == IIR_INDEXED_NAME ){
      procedure_decls = dynamic_cast<IIRScram_IndexedName *>(temp_name)->_get_prefix()->_symbol_lookup();
    }
    else{
      procedure_decls = dynamic_cast<IIRScram_Name *>(temp_name)->_get_prefix()->_symbol_lookup();
    }
    if( procedure_decls == NULL ){
      report_undefined_symbol( temp_name );
    }
    else{
    for(auto it = procedure_decls->begin(); it != procedure_decls->end(); it++)
    {
    ASSERT( *it != NULL );
	if( (*it)->get_kind() == IIR_PROCEDURE_DECLARATION ){
	  found_procedure = true;
	}
	else if( (*it)->get_kind() == IIR_COMPONENT_DECLARATION ){
	  found_component = true;
	}
    }
    }

    if( found_procedure == true && found_component == true ){
      report_ambiguous_error( temp_name, procedure_decls->convert_set<IIR_Declaration*>() );
    }
    else if ( found_procedure == true && found_component == false ){
      proc_call_statement = new IIRScram_ConcurrentProcedureCallStatement();
      copy_location( temp_name, proc_call_statement );
      proc_call_statement->set_label( label );
      proc_call_statement->set_procedure_name(temp_name);      
      $s = proc_call_statement;
      dynamic_cast<IIRScram_ConcurrentStatement *>($s)->_type_check();
    }
    else if ( found_procedure == false && found_component == true ){
      comp_instantiation_statement = new IIRScram_ComponentInstantiationStatement();
      copy_location( temp_name, comp_instantiation_statement );
      comp_instantiation_statement->set_instantiated_unit( temp_name );
      comp_instantiation_statement->set_label( label );
      dynamic_cast<IIRScram_ComponentInstantiationStatement *>(comp_instantiation_statement)->_type_check_instantiated_unit();
      $s = comp_instantiation_statement;
    }
    else{
      ostringstream err;
      err << "|" << *dynamic_cast<IIRScram *>(temp_name) << "| was declared neither as a component or procedure";
      report_error( temp_name, err.str() );
    }
  >>
;

architecture_body[ IIR_LibraryDeclaration *library ] > [IIRScram_ArchitectureDeclaration *retval]:
  <<
    $retval = NULL;
    IIRScram_SimpleName                      *end_name = NULL;
    IIRScram_Identifier                      *name = NULL;
    IIRScram_Name                            *entity_name = NULL;
    IIRScram_ArchitectureDeclaration         *new_arch = NULL;
  >>
  architecture:ARCHITECTURE identifier > [name] 
  <<
    new_arch = new IIRScram_ArchitectureDeclaration();
    new_arch->set_declarator( name );

    copy_location( architecture, new_arch );
    dynamic_cast<IIRScram_ArchitectureDeclaration *>(new_arch)->_add_declaration();
  >>
  OF
  selected_or_simple_name > [entity_name]
  <<
    my_symbol_table->open_scope(new_arch);
    IIRScram_EntityDeclaration *entity_decl = 
      dynamic_cast<IIRScram_EntityDeclaration *>(library_manager::instance()->lookup_entity( TRUE, 
											     entity_name, 
											     library,
											     my_std_package,
											     my_factory));
    if( entity_decl != NULL ){
      new_arch->set_entity( entity_decl );
      if( debug_symbol_table == true ){
	cerr << "Parsing architecture |" << *dynamic_cast<IIRScram_Name *>(name)
	     << "| - going to make entity |" << *dynamic_cast<IIRScram_Name *>(entity_name) << "| visible." << endl;
      }
      (dynamic_cast<IIRScram_Declaration *>(entity_decl))->_make_interface_visible( my_symbol_table );
    }
  >>
  IS
  architecture_declarative_part[new_arch->get_architecture_declarative_part()]
  BEGIN_
  architecture_statement_part[new_arch->get_architecture_statement_part()]
  END {ARCHITECTURE} 
  {
    simple_name > [end_name]
    <<check_name( name, end_name, "architecture" );>>
  } 
  SEMI_COLON
  <<
    $retval = new_arch;
    dynamic_cast<IIRScram_ArchitectureDeclaration *>($retval)->_type_check();
    my_symbol_table->close_scope( new_arch );  
  >>        	  
;

architecture_declarative_part[IIR_DeclarationList *decl_list]:
  ( block_declarative_item[decl_list] )*
;

architecture_statement_part[IIR_ArchitectureStatementList *stmt_list]:
  ( architecture_statement_element[$stmt_list] )*
;

architecture_statement_element[IIR_ArchitectureStatementList *stmt_list]: 
  <<
    IIR                 *cond           = NULL;
    IIR                 *dummy_expr     = NULL;
  >>
  (CASE | NULL_ | PROCEDURAL | IF condition > [cond] USE | simple_expression > [dummy_expr] EQUAL_EQUAL)?
  <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
    simultaneous_statement[$stmt_list]
| concurrent_statement[$stmt_list]
;

configuration_declaration[ IIR_LibraryDeclaration *library ] > [IIRScram_ConfigurationDeclaration *p]:
  <<
    $p = NULL;
    IIRScram_SimpleName                      *end_name = NULL;
    IIRScram_Identifier                      *name = NULL;
    IIRScram_Name                            *entity_name = NULL;
    IIRScram_BlockConfiguration              *block_config = NULL;
    IIRScram_ConfigurationDeclaration        *new_configuration_decl = NULL;
  >>
  configuration:CONFIGURATION identifier > [name] 
  <<
    new_configuration_decl = new IIRScram_ConfigurationDeclaration();
    new_configuration_decl->set_declarator( name );
  
    copy_location( configuration, new_configuration_decl );
    dynamic_cast<IIRScram_ConfigurationDeclaration *>(new_configuration_decl)->_add_declaration_and_open_scope();
  >>
  OF selected_or_simple_name > [entity_name]
  <<
    IIRScram_EntityDeclaration *entity_decl = NULL;
    entity_decl = dynamic_cast<IIRScram_EntityDeclaration *>(library_manager::instance()->lookup_entity( TRUE,
                                                              entity_name,
                                                              library,
                                                              my_std_package,
                                                              my_factory));
    if( entity_decl != NULL ){
      // This means we can't reproduce the qualified name...
      new_configuration_decl->set_entity( entity_decl );
      if( debug_symbol_table == true ){
	cerr << "Parsing configuration |" << *dynamic_cast<IIRScram_Identifier *>(name) << "| - making entity |" 
	     << *dynamic_cast<IIRScram_Name *>(entity_name) << "| visible." << endl;
      }
      (dynamic_cast<IIRScram_Declaration *>(entity_decl))->_make_interface_visible( my_symbol_table );
    }
  >>
  IS
  configuration_declarative_part[ new_configuration_decl->get_configuration_declarative_part() ]
  block_configuration > [ block_config ] 
  <<new_configuration_decl->set_block_configuration( block_config );>>
  END {CONFIGURATION}
  {
    simple_name > [end_name]
    <<check_name( name, end_name, "configuration" );>>
  } 
  SEMI_COLON
  <<
    $p = new_configuration_decl;
    dynamic_cast<IIRScram_ConfigurationDeclaration *>($p)->_type_check();
    my_symbol_table->close_scope( new_configuration_decl );
  >>
;

configuration_declarative_part[IIR_DeclarationList *decl_list ]:
  (configuration_declarative_item[ $decl_list ])*
;

configuration_declarative_item[ IIR_DeclarationList *decl_list ]:
  use_clause[ decl_list ]
| attribute_specification[ decl_list ]
| group_declaration[ decl_list ]
;

block_configuration > [ IIRScram_BlockConfiguration *block_config ]:
  <<
    $block_config = NULL;
    IIRScram_ConfigurationItem *config_item = NULL;
    IIRScram *block_spec = NULL;
  >>
  <<
    // If we get an architecture, we make it's declarative region visible.
    // We'll open and close a scope so that we can get rid of that stuff,
    // too. 
    $block_config = new IIRScram_BlockConfiguration();
    my_symbol_table->open_scope( $block_config );
  >>
  for_:FOR block_specification > [ block_spec ]
  <<
    $block_config->set_block_specification( block_spec );
    copy_location( block_spec, $block_config );
  >>
  ( use_clause[ $block_config->get_use_clause_list() ] )*
  (
    configuration_item > [ config_item ]
    <<$block_config->get_configuration_item_list()->append( config_item );>>
  )*
  END FOR SEMI_COLON
  <<my_symbol_table->close_scope( $block_config );>>
;

// The block specification can be one of three things.
// 1) architecture name
// 2) block statement label
// 3) generate statement label (with index specification)
block_specification > [ IIRScram_Name *block_spec ]:
  <<
    $block_spec                                 = NULL;
    IIRScram_IndexedName *with_index_specification   = NULL;
    IIR             *index_spec                 = NULL;
  >>
  selected_or_simple_name > [ $block_spec ]
  {
    line_info:L_PAREN
    index_specifier > [ index_spec ]
    R_PAREN
    <<
      with_index_specification = new IIRScram_IndexedName();
      copy_location( line_info, with_index_specification );
      with_index_specification->set_prefix( $block_spec );
      with_index_specification->set_suffix( index_spec );
      $block_spec = with_index_specification;
    >>
  }
;

configuration_item > [ IIRScram_ConfigurationItem *config ]:
  <<
    $config = NULL;
  >>
  (component_configuration > [ $config ])?
| block_configuration > [ $config ]
;

component_configuration > [ IIRScram_ComponentConfiguration *component_config ]:
  <<
    $component_config                           = new IIRScram_ComponentConfiguration();
    IIRScram_Name                    *component_name = NULL;
    IIRScram_BlockConfiguration      *block_config   = NULL;
    scram_binding_info_t        *binding_info   = NULL;
  >>
  for_:FOR component_specification[ $component_config->get_instantiation_list() ] > [ component_name ]
  <<
    copy_location( component_name, $component_config );
    $component_config->set_component_name( component_name );
  >>
  {
    binding_indication > [ binding_info ]
    <<
      if( binding_info != NULL ){
        $component_config->set_entity_aspect( binding_info->entity_aspect );
        if( binding_info->generic_map_aspect != NULL ){
	  $component_config->set_generic_map_aspect(binding_info->generic_map_aspect);
        }
        if( binding_info->port_map_aspect != NULL ){
	  $component_config->set_port_map_aspect(binding_info->port_map_aspect);
        }
      }
    >>
    SEMI_COLON
  }
  {
    block_configuration > [ block_config ] 
    <<$component_config->set_block_configuration( block_config );>>
  }
  END FOR SEMI_COLON
;

/* **********************************************************************

concurrent statements

********************************************************************** */

concurrent_statement[IIR_ArchitectureStatementList *stmts]:
  <<
    IIRScram_ArchitectureStatement   *new_stmt       = NULL; 
    IIRScram_Label                   *label          = NULL;
  >>
  { stmt_label > [label] } 
  concurrent_stmt [label] > [new_stmt]
  <<$stmts->append(new_stmt);>>
;

concurrent_stmt [ IIRScram_Label *label ] > [IIRScram_ArchitectureStatement *stmt]:
  <<
    $stmt                               = NULL;
    IIR_Boolean         postpone        = false;
    IIR                 *dummy_expr     = NULL;
    IIRScram_Expression      *cond           = NULL;
  >>
  (
      BLOCK      // block statement
    | FOR | IF   // generate statement (if also for simultaneous_if_statement)
    | BREAK      // concurrent break statement 
    | CASE | NULL_ | PROCEDURAL | simple_expression > [dummy_expr] EQUAL_EQUAL // simultaneous statement
  )?
    not_postponeable [ label ] > [$stmt]
| { POSTPONED <<postpone = true;>> }
  postponeable[ postpone, label ] > [$stmt]
;

not_postponeable [ IIRScram_Label *label ] > [IIRScram_ArchitectureStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *dummy_expr = NULL;
  >>
  block_statement [ label ] > [$stmt]
| (generate_scheme [ label ] > [$stmt] GENERATE)? generate_statement [ label ] > [$stmt]
| (IF | CASE | NULL_ | PROCEDURAL | simple_expression > [dummy_expr] EQUAL_EQUAL)?
  <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
    simultaneous_stmt[label] > [$stmt]
| <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
    concurrent_break_statement[label] > [$stmt] 
;

postponeable[ IIR_Boolean postpone, IIRScram_Label *label ] > [IIRScram_ConcurrentStatement *stmt]:
  <<
    IIR         *name   = NULL;
    IIRScram_Name    *dummy  = NULL;

    // Here are the different types of statements.
    IIRScram_ProcessStatement                        *proc_stmt                      = NULL;
    IIRScram_ConcurrentAssertionStatement            *conc_assert_stmt               = NULL;
    IIRScram_ConcurrentSelectedSignalAssignment      *conc_selected_sig_assign       = NULL;
  >>    
  process_statement[ label ] > [ proc_stmt ]
  <<
    proc_stmt->set_postponed( postpone );
    $stmt = proc_stmt;
  >>
| concurrent_assertion_statement[ label ] > [ conc_assert_stmt ]
  <<
    conc_assert_stmt->set_postponed( postpone );
    $stmt = conc_assert_stmt;
  >>
| selected_signal_assignment_statement[ label ] > [ conc_selected_sig_assign ]
  <<
    conc_selected_sig_assign->set_postponed( postpone );
    $stmt = conc_selected_sig_assign;
  >>
| (target > [name] LESS_EQUAL)? conditional_signal_assignment[ label ] > [$stmt]
| (COMPONENT | ENTITY | CONFIGURATION |
   complex_name > [dummy] 
            (<<IIRScram_AssociationList *dummy1 = new IIRScram_AssociationList();>>
             generic_map_aspect[dummy1] |
             port_map_aspect[dummy1]
             << delete dummy1;>> ) )?
  instantiate_statement[ label ] > [$stmt]
|
  // technically this could still be an instantiate stmt, but it can now
  // only be a component instantiate statement with no port_map_aspect or
  // generic_map_aspect.  if it fails in attempting to build a concurrent
  // procedure call, the action code in concurrent_call_statement will
  //  have to attempt to build a component instantiation statement.
  concurrent_procedure_call[ label ] > [$stmt] 
;

block_statement [ IIRScram_Label *label ] > [IIRScram_BlockStatement *block]:
  <<
    $block                              = NULL;
    IIRScram_SimpleName      *end_name       = NULL;
    IIR                 *guard_expr     = NULL;
  >>
  block_:BLOCK 
  <<
    $block = new IIRScram_BlockStatement();
    $block->set_label( label );
    copy_location( block_, $block );
    my_symbol_table->open_scope( $block );
  >>
  { 
    L_PAREN expression > [guard_expr] R_PAREN
    <<
      $block->set_guard_expression(guard_expr);
      IIRScram_SignalDeclaration *guard_signal = new IIRScram_SignalDeclaration();
      copy_location( guard_expr, guard_signal );
      // This is building the implicit declaration required for the guarded
      // expression as per the LRM.
      guard_signal->set_declarator( IIRScram_Identifier::get( "guard", strlen("guard"), my_factory ) );
      IIRScram_TypeDefinition *bool_type =
	dynamic_cast<IIRScram_TypeDefinition *>(my_std_package->get_boolean_type());
      guard_signal->set_subtype( bool_type );
      $block->set_implicit_guard_signal( guard_signal );
      dynamic_cast<IIRScram_SignalDeclaration *>(guard_signal)->_add_declaration( );
    >>
  }
  { IS }
  block_header[$block]
  block_declarative_part[$block->get_block_declarative_part()]
  BEGIN_
    architecture_statement_part[$block->get_block_statement_part()]
  END BLOCK 
  {
    simple_name > [end_name]
    <<check_name( $block->get_label(), end_name, "block" );>>
  } 
  SEMI_COLON
  <<
    dynamic_cast<IIRScram_BlockStatement *>($block)->_type_check();
    my_symbol_table->close_scope( $block );
  >>
;

block_header[IIRScram_BlockStatement *block]:
  { 
    generic_clause[$block->get_generic_clause()]
    { generic_map_aspect[$block->get_generic_map_aspect()] SEMI_COLON }
  }
  { 
    port_clause[$block->get_port_clause()]
    { port_map_aspect[$block->get_port_map_aspect()] SEMI_COLON }
  }
;

block_declarative_part[IIR_DeclarationList *dl]:
  ( block_declarative_item[$dl] )*
;

block_declarative_item[IIR_DeclarationList *decl_list]:
  subprogram[ decl_list ]
| type_declaration[ decl_list ]
| subtype_declaration[ decl_list ]
| constant_declaration[ decl_list ]
| signal_declaration[ decl_list ]
| shared_variable_declaration[ decl_list ]
| file_declaration[ decl_list ]
| alias_declaration[ decl_list ]
| component_declaration[ decl_list ]
| disconnection_specification[ decl_list ]
| attribute_declarative_item[ decl_list ]
| configuration_specification[ decl_list ]
| use_clause[ decl_list ]
| (LIMIT | NATURE | SUBNATURE | QUANTITY | TERMINAL)?
  <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
  ( step_limit_specification[ decl_list ]
  | nature_declaration[ decl_list ]
  | subnature_declaration[ decl_list ]
  | quantity_declaration[ decl_list ]
  | terminal_declaration[ decl_list ]
  )
| (GROUP IDENTIFIER COLON)? group_declaration[ decl_list ]
| group_template_declaration[ decl_list ]
;

process_statement[ IIRScram_Label *label ] > [IIRScram_ProcessStatement *retval]:
  <<
    $retval = NULL;
    IIRScram_ProcessStatement                *process_stmt                   = NULL;
    IIRScram_SimpleName                      *end_name                       = NULL;
    IIRScram_SensitizedProcessStatement      *sensitive_process_stmt         = NULL;
  >>
  process:PROCESS
  {
    L_PAREN 
    <<
      sensitive_process_stmt = new IIRScram_SensitizedProcessStatement();
      my_symbol_table->open_scope( sensitive_process_stmt );   
      sensitive_process_stmt->set_label( label );

      copy_location( process, sensitive_process_stmt );
      process_stmt = sensitive_process_stmt;
    >>
    sensitivity_list[sensitive_process_stmt->get_sensitivity_list()]
    R_PAREN
  }
  <<
    if (process_stmt == NULL) {
      process_stmt = new IIRScram_ProcessStatement();
      my_symbol_table->open_scope( process_stmt );   
      process_stmt->set_label( label );

      copy_location( process, process_stmt );
    }
    process_stmt->set_postponed( FALSE );
  >>
  { IS }
  process_declarative_part[ process_stmt->get_process_declarative_part() ]
  BEGIN_
  sequence_of_statements[ process_stmt->get_process_statement_part() ]
  END 
  {
    POSTPONED 
    <<process_stmt->set_postponed( TRUE );>>
  }
  PROCESS 
  {
    simple_name > [end_name]
    <<check_name( process_stmt->get_label(), end_name, "process" );>>
  } 
  SEMI_COLON
  <<
    $retval = process_stmt;
    dynamic_cast<IIRScram_ProcessStatement *>($retval)->_type_check();
    my_symbol_table->close_scope( $retval );
  >>
;

process_declarative_part[ IIR_DeclarationList *dl ]:
  ( process_declarative_item[ $dl ] )*
;

process_declarative_item[ IIR_DeclarationList *decl_list ]:
  subprogram[ decl_list ]
| type_declaration[ decl_list ]
| subtype_declaration[ decl_list ]
| constant_declaration[ decl_list ]
| variable_declaration[ decl_list ]
| file_declaration[ decl_list ]
| alias_declaration[ decl_list ]
| attribute_declarative_item[ decl_list ]
| use_clause[ decl_list ]
| (GROUP IDENTIFIER COLON)? group_declaration[ decl_list ]
| group_template_declaration[ decl_list ]
;

concurrent_assertion_statement[ IIRScram_Label *label ] > [IIRScram_ConcurrentAssertionStatement *retval]:
  <<
    $retval = NULL;
    IIRScram_AssertionStatement *assert_stmt = NULL;
  >>
  assertion[ label ] > [ assert_stmt ] SEMI_COLON
  <<
    $retval = new IIRScram_ConcurrentAssertionStatement();
    $retval->set_label( label );
    $retval->set_assertion_condition( assert_stmt->get_assertion_condition() );
    $retval->set_report_expression( assert_stmt->get_report_expression() );
    $retval->set_severity_expression( assert_stmt->get_severity_expression() );
  
    copy_location( assert_stmt, $retval );

    delete assert_stmt;
  >>
;

concurrent_call_statement[ IIRScram_Label *label ] > [IIRScram_ConcurrentProcedureCallStatement *s]: 
  <<IIRScram_Name *procedure_name = NULL;>>
  <<
    $s = new IIRScram_ConcurrentProcedureCallStatement();
    $s->set_label( label );
  >>
  complex_name > [procedure_name] SEMI_COLON
  <<
    $s->set_procedure_name( procedure_name );
    dynamic_cast<IIRScram_ConcurrentProcedureCallStatement *>($s)->_type_check();
  >>
;

instantiate_statement[ IIRScram_Label *label ] > [IIRScram_ComponentInstantiationStatement *retval]: 
  <<
    $retval = NULL;
    IIRScram_Name *component_name = NULL;
  >>
  { COMPONENT } 
  complex_name > [component_name]
  <<
    $retval = new IIRScram_ComponentInstantiationStatement();
    $retval->set_label( label );
    my_symbol_table->open_scope( $retval );   
    $retval->set_instantiated_unit( component_name );
    dynamic_cast<IIRScram_ComponentInstantiationStatement *>($retval)->_set_instantiation_type( IIR_COMPONENT_DECLARATION );
  >>
  { generic_map_aspect[$retval->get_generic_map_aspect()] } 
  { port_map_aspect[$retval->get_port_map_aspect()] }
  token_text1:SEMI_COLON
  <<
    copy_location( token_text1, $retval );
  //  We have to do this on the second pass, since configuration
  //  specifications haven't yet been type checked.
    dynamic_cast<IIRScram_ComponentInstantiationStatement *>($retval)->_type_check_instantiated_unit();
    my_symbol_table->close_scope( $retval );
  >>
| token_text2:ENTITY
  <<
    $retval = new IIRScram_ComponentInstantiationStatement();
    copy_location( token_text2, $retval );    
    $retval->set_label( label );
    my_symbol_table->open_scope( $retval );   

    dynamic_cast<IIRScram_ComponentInstantiationStatement *>($retval)->_set_instantiation_type( IIR_ENTITY_DECLARATION );
  >>
  complex_name > [component_name]
  <<
    $retval->set_instantiated_unit( component_name );
  >>
  { generic_map_aspect[$retval->get_generic_map_aspect()] } 
  { port_map_aspect[$retval->get_port_map_aspect()] } 
  SEMI_COLON
  <<
  //  We have to do this on the second pass, since configuration
  //  specifications haven't yet been type checked.
    dynamic_cast<IIRScram_ComponentInstantiationStatement *>($retval)->_type_check_instantiated_unit();
    my_symbol_table->close_scope( $retval );
  >>
| token_text3:CONFIGURATION
  <<
    $retval = new IIRScram_ComponentInstantiationStatement();
    copy_location( token_text3, $retval );
    $retval->set_label( label );
    my_symbol_table->open_scope( $retval );   
    dynamic_cast<IIRScram_ComponentInstantiationStatement *>($retval)->_set_instantiation_type( IIR_CONFIGURATION_DECLARATION );
  >>
  complex_name > [component_name]
  <<
    $retval->set_instantiated_unit( component_name );
  >>
  { generic_map_aspect[$retval->get_generic_map_aspect()] } 
  { port_map_aspect[$retval->get_port_map_aspect()] } 
  SEMI_COLON
  <<
  // We have to do this on the second pass, since configuration
  // specifications haven't yet been type checked.
    dynamic_cast<IIRScram_ComponentInstantiationStatement *>($retval)->_type_check_instantiated_unit();
    my_symbol_table->close_scope( $retval );
  >>
;

conditional_signal_assignment[ IIRScram_Label *label ] > [IIRScram_ConcurrentConditionalSignalAssignment *stmt]: 
  <<
    $stmt                               = NULL;
    IIR                 *destination    = NULL;
    IIR                 *reject         = NULL;
    IIR_Boolean         guarded;
    IIR_DelayMechanism  delay           = IIR_INERTIAL_DELAY;
  >>
  target > [destination]
  le:LESS_EQUAL
  options > [guarded, delay, reject] 
  <<
    $stmt = new IIRScram_ConcurrentConditionalSignalAssignment();
    $stmt->set_label( label );
    copy_location( le,  $stmt );
  >>
  conditional_waveforms[$stmt->get_conditional_waveforms()]
  SEMI_COLON
  <<
    $stmt->set_target(destination);
    $stmt->set_guarded(guarded);
    $stmt->set_delay_mechanism(delay);
    $stmt->set_reject_time_expression(reject);
    dynamic_cast<IIRScram_ConcurrentConditionalSignalAssignment *>($stmt)->_type_check();
  >>
;

target > [IIRScram *retval]: 
  <<
    $retval = NULL;
    IIRScram_Aggregate *new_aggregate = NULL;
  >>
  complex_name > [$retval]
| aggregate > [new_aggregate]
  <<$retval = reduce_aggregate( dynamic_cast<IIRScram_Aggregate *>(new_aggregate) );>>
;

aggregate > [IIRScram_Aggregate *retval] :
  <<$retval = NULL;>>
  info:L_PAREN 
  <<
    $retval = new IIRScram_Aggregate();
    copy_location( info, $retval );
  >>
  aggregate_entry[ $retval ]
  ( COMMA  aggregate_entry[ $retval ] )* 
  R_PAREN
;

aggregate_entry[ IIRScram_Aggregate *aggregate_in ] : 
  <<
    IIRScram_CaseStatementAlternative        *formal_or_actual       = NULL;
    IIRScram_CaseStatementAlternative        *formal_part            = NULL;
    IIR                                 *actual_part            = NULL;
  >>
  choices > [ formal_or_actual ]
  { EQUAL_GREATER expression > [ actual_part ] }
  <<
    if( actual_part != NULL ){
      formal_part = formal_or_actual;
      // and actual is already set
    }
    else{
      actual_part = formal_or_actual;
      // and formal is NULL by default. 
    }
    process_aggregate_with_choices( dynamic_cast<IIRScram_CaseStatementAlternative *>(formal_part), 
                                    dynamic_cast<IIRScram *>(actual_part), 
                                    dynamic_cast<IIRScram_Aggregate *>(aggregate_in) );
  >>
;

conditional_waveforms[IIR_ConditionalWaveformList *list]:
  <<
    IIRScram_ConditionalWaveform     *wave = NULL;
    IIR                         *expr = NULL;
  >>
  <<
    wave = new IIRScram_ConditionalWaveform();
    $list->append(wave);
  >>
  concurrent_waveform[wave->get_waveform()]
  {
    WHEN condition > [expr] <<wave->set_condition(expr);>>
    { ELSE conditional_waveforms[list] }
  }
;

selected_signal_assignment_statement[ IIRScram_Label *label ] > [ IIRScram_ConcurrentSelectedSignalAssignment *stmt]:
  <<
    $stmt                               = NULL;
    IIR                 *selector       = NULL;
    IIR                 *destination    = NULL;
    IIR_Boolean         guard;
    IIR_DelayMechanism  delay_mech      = IIR_INERTIAL_DELAY;
    IIR                 *reject_lim     = NULL;
  >>
  with:WITH 
  expression > [selector] SELECT
  <<
    $stmt = new IIRScram_ConcurrentSelectedSignalAssignment();
    $stmt->set_label( label );
    copy_location( with, $stmt );
  >>
  target > [destination] LESS_EQUAL
  options > [ guard, delay_mech, reject_lim ] 
  selected_waveforms[$stmt->get_selected_waveforms()] SEMI_COLON
  <<
    $stmt->set_target(destination);
    $stmt->set_expression( selector );
    $stmt->set_guarded( guard );
    $stmt->set_delay_mechanism( delay_mech );
    $stmt->set_reject_time_expression( reject_lim );
    dynamic_cast<IIRScram_ConcurrentSelectedSignalAssignment *>($stmt)->_type_check();
  >>
;

selected_waveforms[IIR_SelectedWaveformList *list]:
  <<
    IIRScram_SelectedWaveform                *wave   = NULL;
    IIRScram_CaseStatementAlternative        *choice = NULL;
  >>
  <<wave = new IIRScram_SelectedWaveform();>>
  concurrent_waveform[wave->get_waveform()] 
  WHEN choices > [choice] 
  <<
    wave->set_choice( choice );
    list->append( wave );
  >>
  ( 
    COMMA <<wave = new IIRScram_SelectedWaveform();>>
    concurrent_waveform[wave->get_waveform()] 
    WHEN choices > [ choice ]
    <<
      wave->set_choice( choice );
      list->append( wave );
    >>
  )* 
;

options > [IIR_Boolean guard, IIR_DelayMechanism delay_mech, IIRScram *reject_lim]:
  <<
    $guard = false;
    $delay_mech = IIR_INERTIAL_DELAY;
    $reject_lim = NULL;
  >>
  { GUARDED <<$guard = TRUE;>> }
  { delay_mechanism > [$delay_mech, $reject_lim] }
;

delay_mechanism > [IIR_DelayMechanism d, IIRScram *e]: 
  <<
    $d = IIR_INERTIAL_DELAY;
    $e = NULL;
  >>
  TRANSPORT <<$d = IIR_TRANSPORT_DELAY;>>
| { REJECT_ time_expression > [$e] } 
  INERTIAL <<$d = IIR_INERTIAL_DELAY;>>
;

generate_statement[ IIRScram_Label *label ] > [IIRScram_ConcurrentStatement *generate_stmt]:
  <<
    $generate_stmt                                      = NULL;
    IIRScram_SimpleName                      *end_name       = NULL;
    IIRScram_ArchitectureStatementList       *stmt_list      = new IIRScram_ArchitectureStatementList();
    IIRScram_DeclarationList                 *decl_list      = new IIRScram_DeclarationList();
  >>
  generate_scheme[ label ] > [ $generate_stmt ]
  GENERATE
  {
    (<<IIRScram_DeclarationList *dummy;>> block_declarative_part[dummy] BEGIN_ <<delete dummy;>>)?
    block_declarative_part[ decl_list ] 
    BEGIN_
  }
  architecture_statement_part[stmt_list]
  <<
    IIRScram_ConcurrentGenerateForStatement  *for_stmt       = NULL;
    IIRScram_ConcurrentGenerateIfStatement   *if_stmt        = NULL;
    if( $generate_stmt->get_kind() == IIR_CONCURRENT_GENERATE_FOR_STATEMENT ){
      for_stmt = dynamic_cast<IIRScram_ConcurrentGenerateForStatement *>($generate_stmt);
      for_stmt->set_concurrent_statement_part(dynamic_cast<IIRScram_ArchitectureStatementList *>(IIRScram_List::_listcopy(dynamic_cast<IIRScram_List *>(stmt_list), my_factory)));
      for_stmt->set_block_declarative_part(dynamic_cast<IIRScram_DeclarationList *>(IIRScram_List::_listcopy(dynamic_cast<IIRScram_List *>(decl_list), my_factory)));
//      IIRScram_List::_listcopy( dynamic_cast<IIRScram_List *>(for_stmt->get_concurrent_statement_part()), 
//                                dynamic_cast<IIRScram_List *>(stmt_list) );
//      IIRScram_List::_listcopy( dynamic_cast<IIRScram_List *>(for_stmt->get_block_declarative_part()),
//                                dynamic_cast<IIRScram_List *>(decl_list) );
      $generate_stmt = for_stmt;
    }
    else if ( $generate_stmt->get_kind() == IIR_CONCURRENT_GENERATE_IF_STATEMENT ){
      if_stmt = dynamic_cast<IIRScram_ConcurrentGenerateIfStatement *>($generate_stmt);
      if_stmt->set_concurrent_statement_part(dynamic_cast<IIRScram_ArchitectureStatementList *>(IIRScram_List::_listcopy(dynamic_cast<IIRScram_List *>(stmt_list), my_factory)));
      if_stmt->set_block_declarative_part(dynamic_cast<IIRScram_DeclarationList *>(IIRScram_List::_listcopy(dynamic_cast<IIRScram_List *>(decl_list), my_factory)));
//      IIRScram_List::_listcopy( dynamic_cast<IIRScram_List *>(if_stmt->get_concurrent_statement_part()),
//                                dynamic_cast<IIRScram_List *>(stmt_list) );
//      IIRScram_List::_listcopy( dynamic_cast<IIRScram_List *>(if_stmt->get_block_declarative_part()),
//                                dynamic_cast<IIRScram_List *>(decl_list) );
      $generate_stmt = if_stmt;
    }
    else {
      panic( "rule \"generation_scheme\" returned invalid node." );
    }
  >>
  END GENERATE
  {
    simple_name > [end_name]
    <<check_name( $generate_stmt->get_label(), end_name, "generate");>>
  }
  SEMI_COLON
  <<
    dynamic_cast<IIRScram_ConcurrentStatement *>($generate_stmt)->_type_check();
    my_symbol_table->close_scope( $generate_stmt );
    delete stmt_list;
    delete decl_list;
  >>
;

generate_scheme[ IIRScram_Label *label ] > [IIRScram_ConcurrentStatement *retval]:
  <<
    $retval = NULL;
    IIRScram_ConcurrentGenerateForStatement  *generate_for_stmt      = NULL;
    IIRScram_ConcurrentGenerateIfStatement   *generate_if_stmt       = NULL;
    IIRScram_Identifier                      *for_parameter          = NULL;
    IIRScram_ScalarTypeDefinition            *index_range            = NULL;
    IIR                                 *if_condition           = NULL;
  >>
  for_:FOR
  <<
    generate_for_stmt = new IIRScram_ConcurrentGenerateForStatement();
    my_symbol_table->open_scope( generate_for_stmt );
    generate_for_stmt->set_label( label );
    copy_location( for_, generate_for_stmt );
    $retval = generate_for_stmt;
  >>
  identifier > [ for_parameter ] IN
  discrete_range > [index_range]
  <<
    if( index_range != NULL ){
      IIRScram_ConstantDeclaration *parameter_decl = new IIRScram_ConstantDeclaration();
      parameter_decl->set_is_implicit( true );
      copy_location( for_parameter, parameter_decl );
      parameter_decl->set_declarator( for_parameter );
      if( index_range->get_kind() == IIR_RANGE_TYPE_DEFINITION ){
        IIRScram_RangeTypeDefinition *temp = dynamic_cast<IIRScram_RangeTypeDefinition *>(index_range);
        if( temp->get_right() != NULL ){
	  index_range = IIRScram_ScalarTypeDefinition::_determine_discrete_type(dynamic_cast<IIRScram_RangeTypeDefinition *>(temp));
	  index_range = dynamic_cast<IIRScram_ScalarTypeDefinition *>(dynamic_cast<IIRScram_ScalarTypeDefinition *>(index_range)->_construct_new_subtype( NULL, dynamic_cast<IIRScram_RangeTypeDefinition *>(temp)));
	  parameter_decl->set_subtype( index_range );
	  copy_location( for_, parameter_decl->get_subtype() );
	  delete temp;
        }
      }
      else{
        parameter_decl->set_subtype( index_range );  
      }
      generate_for_stmt->set_generate_parameter_specification( parameter_decl );

      dynamic_cast<IIRScram_ConstantDeclaration *>(parameter_decl)->_add_declaration();
    }
  >>
| if_:IF
  <<
    generate_if_stmt = new IIRScram_ConcurrentGenerateIfStatement();
    my_symbol_table->open_scope( generate_if_stmt );
    generate_if_stmt->set_label( label );
    copy_location( if_, generate_if_stmt );
    $retval = generate_if_stmt;
  >>
  condition > [if_condition]
  <<generate_if_stmt->set_if_condition( if_condition );>>
;

/* **********************************************************************

sequential statements

********************************************************************** */

sequence_of_statements[IIR_SequentialStatementList *stmt_list]:
  <<IIRScram_SequentialStatement *stmt = NULL;>>
  ( sequential_statement > [stmt] <<$stmt_list->append(stmt);>> )*
;

sequential_statement > [IIRScram_SequentialStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram_Label *label = NULL;
  >>
  { stmt_label > [label] }
  sequential_stmt[ label ] > [$stmt] SEMI_COLON
;

sequential_stmt[ IIRScram_Label *label ] > [IIRScram_SequentialStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *name = NULL;
  >>
  wait_statement[ label ] > [$stmt]
| assertion_statement[ label ] > [$stmt]
| report_statement[ label ] > [$stmt]
| (NULL_)? null_statement[ label ] > [$stmt]
| (target > [name] LESS_EQUAL)? signal_assignment_statement[ label ] > [$stmt]
| (target > [name] COLON_EQUAL)? variable_assignment_statement[ label ] > [$stmt]
| (complex_name > [name] SEMI_COLON)? procedure_call_statement[ label ] > [$stmt]
| if_statement[ label ] > [$stmt]
| case_statement[ label ] > [$stmt]
| loop_statement[ label ] > [$stmt]
| next_statement[ label ] > [$stmt]
| exit_statement[ label ] > [$stmt]
| return_statement[ label ] > [$stmt]
| <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
    break_statement[label] > [$stmt]
;

stmt_label > [IIRScram_Label *label]:
  <<$label = NULL;>>
  vhdl_label > [$label] COLON
  <<dynamic_cast<IIRScram_Label *>($label)->_add_declaration( );>>
;

wait_statement[ IIRScram_Label *label ] > [IIRScram_WaitStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *clause = NULL;
  >>
  wait:WAIT 
  <<
    $stmt = new IIRScram_WaitStatement();
    copy_location( wait, $stmt );
    $stmt->set_label( label );
  >>
  { sensitivity_clause[$stmt->get_sensitivity_list()] }
  { condition_clause > [clause] <<$stmt->set_condition_clause(clause);>> }
  { timeout_clause > [clause] <<$stmt->set_timeout_clause(clause);>> }
  <<dynamic_cast<IIRScram_WaitStatement *>($stmt)->_type_check();>>
;

sensitivity_clause[IIR_DesignatorList *siglist]:
  ON sensitivity_list[$siglist]
;

sensitivity_list[ IIR_DesignatorList *siglist ]:
  <<IIRScram_Name *name = NULL;>>
  complex_name > [name] 
  <<
    IIRScram_DesignatorExplicit *designator = new IIRScram_DesignatorExplicit();
    copy_location( name, designator );
    designator->set_name( name );
    $siglist->append(designator);
  >>
  (
    COMMA complex_name > [name] 
    <<
      IIRScram_DesignatorExplicit *designator = new IIRScram_DesignatorExplicit();
      copy_location( name, designator );
      designator->set_name( name );
      $siglist->append(designator);
    >>
  )*
;

condition_clause > [IIRScram *expr]:
  <<$expr = NULL;>>
  UNTIL condition > [$expr]
;

condition > [IIRScram *expr]:
  <<$expr = NULL;>>
  boolean_expression > [$expr]
;

timeout_clause > [IIRScram *expr]:
  <<$expr = NULL;>>
  FOR time_expression > [$expr]
;

assertion_statement[ IIRScram_Label *label ] > [IIRScram_AssertionStatement *stmt]:
  <<$stmt = NULL;>>
  assertion[ label ] > [$stmt]
;

assertion[ IIRScram_Label *label ] > [IIRScram_AssertionStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *clause = NULL;
  >>
  assert:ASSERT 
  <<
    $stmt = new IIRScram_AssertionStatement();
    copy_location( assert, $stmt );
    $stmt->set_label( label );
  >>
  condition > [clause] <<$stmt->set_assertion_condition(clause);>>
  { REPORT expression > [clause] <<$stmt->set_report_expression(clause);>> }
  { SEVERITY expression > [clause] <<$stmt->set_severity_expression(clause);>> }
  <<dynamic_cast<IIRScram_AssertionStatement *>($stmt)->_type_check();>>
;

report_statement[ IIRScram_Label *label ] > [IIRScram_ReportStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *expr = NULL;
  >>
  report:REPORT
  <<
    $stmt = new IIRScram_ReportStatement();
    copy_location( report, $stmt );
    $stmt->set_label( label );
  >>
  expression > [expr] <<$stmt->set_report_expression(expr);>>
  { SEVERITY expression > [expr] <<$stmt->set_severity_expression(expr);>> }
  <<dynamic_cast<IIRScram_ReportStatement *>($stmt)->_type_check();>>
;

null_statement[ IIRScram_Label *label ] > [IIRScram_NullStatement *stmt]:
  <<$stmt = NULL;>>
  null_:NULL_
  <<
    $stmt = new IIRScram_NullStatement();
    copy_location( null_, $stmt );
    $stmt->set_label( label );
    dynamic_cast<IIRScram_NullStatement *>($stmt)->_type_check();
  >>
;

signal_assignment_statement[ IIRScram_Label *label ] > [IIRScram_SignalAssignmentStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *name = NULL;
  >>
  target > [name] 
  less_equal:LESS_EQUAL 
  sequential_signal_assign_stmt[name, label] > [$stmt]
  <<
    copy_location( less_equal, $stmt );
    dynamic_cast<IIRScram_SignalAssignmentStatement *>($stmt)->_type_check();
  >>
;

variable_assignment_statement[ IIRScram_Label *label] > [IIRScram_VariableAssignmentStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *name = NULL;
  >>
  target > [name] 
  colon_equal:COLON_EQUAL 
  variable_assign_stmt[name, label] > [$stmt]
  <<
    copy_location( colon_equal, $stmt );
    dynamic_cast<IIRScram_VariableAssignmentStatement *>($stmt)->_type_check();
  >>
;

procedure_call_statement[ IIRScram_Label *label ] > [IIRScram_ProcedureCallStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *name = NULL;
  >>
  <<
    $stmt = new IIRScram_ProcedureCallStatement();
    $stmt->set_label( label );
  >>
  complex_name > [name]
  <<
    copy_location( name,  $stmt );
    $stmt->set_procedure_name(name);
    dynamic_cast<IIRScram_ProcedureCallStatement *>($stmt)->_type_check();
  >>
;

sequential_signal_assign_stmt[IIRScram *dest, IIRScram_Label *label] > [IIRScram_SignalAssignmentStatement *stmt]: 
  <<
    $stmt = NULL;
    IIR_DelayMechanism d = IIR_INERTIAL_DELAY;
    IIRScram *e = NULL;
  >>
  <<
    $stmt = new IIRScram_SignalAssignmentStatement();
    $stmt->set_label( label );
    $stmt->set_target( dest );
  >>
  { delay_mechanism > [d, e] }
  <<
    $stmt->set_delay_mechanism(d);
    $stmt->set_reject_time_expression(e);
  >>
  sequential_waveform[$stmt->get_waveform()]
;

variable_assign_stmt[IIRScram *dest, IIRScram_Label *label ] > [IIRScram_VariableAssignmentStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *expr = NULL;
  >>
  <<
    $stmt = new IIRScram_VariableAssignmentStatement();
    $stmt->set_label( label );
    $stmt->set_target(dest);
  >>
  expression > [expr] 
  <<$stmt->set_expression(expr);>>
;

sequential_waveform[IIR_WaveformList *wavelist]:
  <<IIRScram_WaveformElement *wave = NULL;>>
  waveform_element > [wave] <<$wavelist->append(wave);>>
  ( COMMA waveform_element > [wave] <<$wavelist->append(wave);>> )*
;

concurrent_waveform[IIR_WaveformList *wavelist]:
  <<IIRScram_WaveformElement *wave = NULL;>>
  sequential_waveform[$wavelist]
| unaffected:UNAFFECTED 
  <<
    wave = new IIRScram_WaveformElement();
    copy_location( unaffected, wave );
    wave->set_value(NULL);
    wave->set_time(NULL);
  >>
;

waveform_element > [IIRScram_WaveformElement *wave]:
  <<
    $wave = NULL;
    IIRScram *value = NULL;
    IIRScram *time = NULL;
  >>
  expression > [value] { AFTER expression > [time] }
  <<
    $wave = new IIRScram_WaveformElement();
    copy_location( value, $wave );
    $wave->set_value(value);
    $wave->set_time(time);
  >>
;

if_statement[ IIRScram_Label *label ] > [IIRScram_IfStatement *stmt]:
  <<
    $stmt = NULL;
    IIR                 *cond           = NULL;
    IIRScram_SimpleName      *end_name       = NULL;
    IIRScram_Elsif           *elsif          = NULL;
  >>
  if_:IF 
  <<
    $stmt = new IIRScram_IfStatement();
    $stmt->set_label( label );
    copy_location( if_, $stmt );
  >>
  condition > [cond] <<$stmt->set_condition(cond);>>
  THEN sequence_of_statements[$stmt->get_then_sequence()]
  { (ELSIF)? elsif_stmt > [elsif] <<$stmt->set_elsif(elsif);>> }
  { else_:ELSE sequence_of_statements[$stmt->get_else_sequence()] }
  END IF 
  { 
    simple_name > [end_name]
    <<check_name( $stmt->get_label(), end_name, "if statement" );>> 
  }
  <<dynamic_cast<IIRScram_IfStatement *>($stmt)->_type_check();>>
;

elsif_stmt > [IIRScram_Elsif *stmt]:
  <<
    $stmt                       = NULL;
    IIR         *cond           = NULL;
    IIRScram_Elsif   *next_elsif     = NULL;
  >>
  elsif_:ELSIF
  <<
    $stmt = new IIRScram_Elsif();
    copy_location( elsif_, $stmt );
  >>
  condition > [cond]
  THEN sequence_of_statements[$stmt->get_then_sequence_of_statements()]
  <<$stmt->set_condition(cond);>>
  {
    (ELSIF)? elsif_stmt > [next_elsif]
    <<$stmt->set_else_clause(next_elsif);>>
  }
;

case_statement[ IIRScram_Label *label ] > [IIRScram_CaseStatement *stmt]:
  <<
    $stmt                               = NULL;
    IIRScram_SimpleName      *end_name       = NULL;
    IIR                 *expr           = NULL;
  >>
  case_:CASE
  <<
    $stmt = new IIRScram_CaseStatement();
    $stmt->set_label( label );
    copy_location( case_, $stmt );
  >>
  expression > [expr] IS
  <<$stmt->set_expression(expr);>> 
  ( case_statement_alternative[$stmt->get_case_statement_alternatives()] )+
  END CASE 
  {
    simple_name > [ end_name ]
    <<check_name( $stmt->get_label(), end_name, "case statement" );>>
  }
  <<dynamic_cast<IIRScram_CaseStatement *>($stmt)->_type_check();>>
;

case_statement_alternative[IIR_CaseStatementAlternativeList *alt_list]:
  <<IIRScram_CaseStatementAlternative *alt = NULL;>>
  when:WHEN choices > [alt] equal_greater_:EQUAL_GREATER
  sequence_of_statements[alt->get_sequence_of_statements()]
  <<
    // if we have an empty statement set, insert a null statement
    if( alt->get_sequence_of_statements()->first() == NULL ){
      IIRScram_NullStatement *stmt = new IIRScram_NullStatement();
      copy_location( equal_greater_, stmt );
      alt->get_sequence_of_statements()->append(stmt);
    };
    copy_location( when, alt );
    $alt_list->append(alt);
  >>
;

choices > [IIRScram_CaseStatementAlternative *alt]:
  <<
    $alt                                                        = NULL;
    IIRScram_Choice                                  *ch             = NULL;
    IIRScram_CaseStatementAlternativeByChoices       *byChoices      = NULL;
    IIRScram_CaseStatementAlternativeByExpression    *byExpression   = NULL;
  >>
  <<byExpression = new IIRScram_CaseStatementAlternativeByExpression();>>
  choice > [ch]
  <<
    byExpression->set_choice(ch);
    copy_location( ch, byExpression );
    $alt = byExpression;
  >>
  ( 
    CHOICE
    <<
      if (byChoices == NULL) {
	delete byExpression;
	byChoices = new IIRScram_CaseStatementAlternativeByChoices();
	$alt = byChoices;
	byChoices->get_choices()->append(ch);
	copy_location( ch, byChoices );
      };
    >>
    choice > [ch]
    <<
      byChoices->get_choices()->append(ch);
      copy_location( ch, byChoices );
    >>
  )*
| oth:OTHERS
  <<
    $alt = new IIRScram_CaseStatementAlternativeByOthers();
    copy_location( oth, $alt );
  >>
;

choice > [IIRScram_Choice *ch]:
  <<
    $ch                                         = NULL;
    IIR                         *expr           = NULL;
    IIRScram_RangeTypeDefinition     *range_type_def = NULL;
    IIRScram_ScalarTypeDefinition    *scalar_type    = NULL;
    IIR                         *dir            = NULL;
    IIR                         *right          = NULL;
  >>
  expression > [expr]
  <<
    $ch = new IIRScram_Choice();
    copy_location( expr, $ch );
    $ch->set_value(expr);
  >>
  { 
    direction > [dir] simple_expression > [right]
    <<
      range_type_def = new IIRScram_RangeTypeDefinition();
      copy_location( dir, range_type_def );
      range_type_def->set_left(expr);
      range_type_def->set_direction( dir );
      range_type_def->set_right(right);
      scalar_type = IIRScram_ScalarTypeDefinition::_determine_discrete_type(dynamic_cast<IIRScram_RangeTypeDefinition *>(range_type_def));
      scalar_type = 
	dynamic_cast<IIRScram_ScalarTypeDefinition *>(dynamic_cast<IIRScram_ScalarTypeDefinition *>(scalar_type)->_construct_new_subtype( NULL, dynamic_cast<IIRScram_RangeTypeDefinition *>(range_type_def)));
      $ch->set_value( scalar_type );
    >>
  }
;

loop_statement[ IIRScram_Label *label ] > [IIRScram_SequentialStatement *stmt]:
  <<$stmt = NULL;>>
  (FOR)? for_loop_statement[ label ] > [$stmt]
| while_loop_statement[ label ] > [$stmt]
;

for_loop_statement[ IIRScram_Label *label ] > [IIRScram_ForLoopStatement *stmt]:
  <<
    $stmt                                       = NULL;
    IIRScram_Identifier              *id               = NULL;
    IIRScram_ScalarTypeDefinition    *constant_subtype = NULL;
    IIRScram_SimpleName              *end_name         = NULL;
  >>
  for_:FOR identifier > [id] IN discrete_range > [constant_subtype] LOOP
  <<
    $stmt = new IIRScram_ForLoopStatement();
    copy_location( for_, $stmt );
    
    loop_statements.push( $stmt );
    $stmt->set_label( label );
    my_symbol_table->open_scope( $stmt );
    $stmt->_build_iteration_scheme( id, constant_subtype );
    $stmt->_type_check();
  >>
  sequence_of_statements[$stmt->get_sequence_of_statements()]
  END LOOP 
  { 
    simple_name > [end_name] 
    <<check_name( $stmt->get_label(), end_name, "for loop statement" );>>
  }
  <<
    my_symbol_table->close_scope( $stmt );
    loop_statements.pop();
  >>
;

while_loop_statement[ IIRScram_Label *label ] > [IIRScram_WhileLoopStatement *stmt]:
  <<
    $stmt                               = NULL;
    IIR                 *cond           = NULL;
    IIRScram_SimpleName      *end_name       = NULL;
  >>
  { WHILE condition > [cond] } loop_:LOOP
  <<
    $stmt = new IIRScram_WhileLoopStatement();
    loop_statements.push( $stmt );
    $stmt->set_label( label );
    copy_location( loop_, $stmt );
    $stmt->set_while_condition(cond);
  >>
  sequence_of_statements[$stmt->get_sequence_of_statements()]
  END LOOP 
  { 
    simple_name > [end_name]
    <<check_name( $stmt->get_label(), end_name, "while loop statement" );>>
  }
  <<
    dynamic_cast<IIRScram_WhileLoopStatement *>($stmt)->_type_check();
    loop_statements.pop();
  >>
;

next_statement[ IIRScram_Label *label ] > [IIRScram_NextStatement *stmt]:
  <<
    $stmt                               = NULL;
    IIRScram_Label           *goto_label     = NULL;
    IIR                 *expr           = NULL;
  >>
  next:NEXT
  <<
    $stmt = new IIRScram_NextStatement();
    $stmt->set_label( label );
    copy_location( next, $stmt );
  >>
  { 
    vhdl_label > [goto_label]
    <<
      savant::set<IIR_Declaration*> *label_decls = NULL;
      IIRScram_TextLiteral *label_text =
	dynamic_cast<IIRScram_TextLiteral *>(goto_label->get_declarator());
      label_decls = new savant::set<IIR_Declaration*>( *(my_symbol_table->find_set(label_text))); 
      if( label_decls == NULL ){
	report_undefined_symbol( goto_label );
      }
      else{
      for(auto it = label_decls->begin(); it != label_decls->end(); )
      {
      ASSERT( *it != NULL);
	  if( (*it)->get_kind() != IIR_LABEL ){
	    it = label_decls->erase( it );
	  } else
      it++;
      }
	switch( label_decls->size() ){
	case 0:{
	  ostringstream err;
	  err << "|" << *dynamic_cast<IIRScram_Label *>(goto_label) << "| was not defined as a label in this scope.";
	  report_error( $stmt, err.str() );
	  // We don't need this temporary label any more...
	  delete goto_label;
	  goto_label = NULL;
	  break;
	}
	case 1:{
	  // We don't need this temporary label any more...
	  delete goto_label;

	  ASSERT( *label_decls->begin() != NULL );
	  goto_label = dynamic_cast<IIRScram_Label *>(*label_decls->begin());
	  ASSERT( goto_label != NULL );
	  break;
	}
	default:{
	  report_ambiguous_error( goto_label, label_decls );
	  break;
	}
	}

	if( goto_label != NULL ){
	  IIRScram_Statement *next_statement  = dynamic_cast<IIRScram_Statement *>(goto_label->get_statement());
	  if( dynamic_cast<IIRScram_Statement *>(next_statement)->_is_iir_sequential_statement() == TRUE ){
	    $stmt->set_enclosing_loop( dynamic_cast<IIRScram_SequentialStatement *>(next_statement) );
	  }
	  else{
	    ostringstream err;
	    err << "Next statements may only be used with sequential statements.  ";
	    err << "|" << *dynamic_cast<IIRScram_Label *>(goto_label) << "| denotes a concurrent statement.";
	    report_error ( $stmt, err.str() );
	  }
	}
      }
    >>
  }
  { WHEN condition > [expr] <<$stmt->set_condition(expr);>> }
  <<
    if( $stmt->get_enclosing_loop() == NULL ){
      IIRScram_SequentialStatement *loop_statement = loop_statements.get_top_of_stack();
      $stmt->set_enclosing_loop( dynamic_cast<IIR_SequentialStatement *>(loop_statement) );
    }
    dynamic_cast<IIRScram_NextStatement *>($stmt)->_type_check();
  >>
;

exit_statement[ IIRScram_Label *label ] > [IIRScram_ExitStatement *stmt]:
  <<
    $stmt                               = NULL;
    IIRScram_Label           *exit_label     = NULL;
    IIR                 *expr           = NULL;
  >>
  exit:EXIT
  <<
    $stmt = new IIRScram_ExitStatement();
    $stmt->set_label( label );
    copy_location( exit, $stmt );
  >>
  { 
    vhdl_label > [exit_label] 
    <<
      savant::set<IIR_Declaration*> *label_decls = NULL;
      IIRScram_TextLiteral *label_text =
	dynamic_cast<IIRScram_TextLiteral *>(exit_label->get_declarator());
      label_decls = new savant::set<IIR_Declaration*>(* ( my_symbol_table->find_set( label_text ) ) ); 
      if( label_decls == NULL ){
	report_undefined_symbol( exit_label );
      }
      else{
      for(auto it = label_decls->begin(); it != label_decls->end(); )
      {
      ASSERT( *it != NULL );
	  if( (*it)->get_kind() != IIR_LABEL ){
	    it = label_decls->erase( it );
	  } else
      it++;
      }
	switch( label_decls->size() ){
	case 0:{
	  ostringstream err;
	  err << "|" << * dynamic_cast<IIRScram_Label *>(exit_label) << "| was not defined as a label in this scope.";
	  report_error( $stmt, err.str() );
	  // We don't need this temporary label any more...
	  delete exit_label;
	  exit_label = NULL;
	  break;
	}
	case 1:{
	  // We don't need this temporary label any more...
	  delete exit_label;
     ASSERT( *label_decls->begin() != NULL );
	  exit_label = dynamic_cast<IIRScram_Label *>(*label_decls->begin());
     ASSERT( exit_label != NULL );
	  break;
	}
	default:{
	  report_ambiguous_error( exit_label, label_decls );
	  break;
	}
	}

	if( exit_label != NULL ){
	  IIRScram_Statement *exit_statement =
	    dynamic_cast<IIRScram_Statement *>(exit_label->get_statement());
	  if( exit_statement->_is_iir_sequential_statement() == TRUE ){
	    $stmt->set_enclosing_loop( dynamic_cast<IIR_SequentialStatement *>(exit_statement) );
	  }
	  else{
	    ostringstream err;
	    err << "Next statements may only be used with sequential statements.  ";
	    err << "|" << *dynamic_cast<IIRScram_Label *>(exit_label) << "| denotes a concurrent statement.";
	    report_error ( $stmt, err.str() );
	  }
	}
      }
    >>
  }
  { WHEN condition > [expr] <<$stmt->set_condition(expr);>> }
  <<dynamic_cast<IIRScram_ExitStatement *>($stmt)->_type_check();>>
;

return_statement[ IIRScram_Label *label ] > [IIRScram_ReturnStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *expr = NULL;
  >>
  return_:RETURN
  <<
    $stmt = new IIRScram_ReturnStatement();
    $stmt->set_label( label );
    copy_location( return_, $stmt );
  >>
  { expression > [expr] <<$stmt->set_return_expression(expr);>> }
  <<dynamic_cast<IIRScram_ReturnStatement *>($stmt)->_type_check();>>
;

/***********************************************************************
           package specifications and declarations
***********************************************************************/

package_declaration > [IIRScram_PackageDeclaration *package_decl]:
  <<
    $package_decl                       = NULL;
    IIRScram_Identifier      *package_name   = NULL;
    IIRScram_Name            *end_name       = NULL;
  >>
  package:PACKAGE_
  <<
    $package_decl = new IIRScram_PackageDeclaration();
    copy_location( package, $package_decl );
  >>
  identifier > [package_name]
  <<
    $package_decl->set_declarator( package_name );
    dynamic_cast<IIRScram_PackageDeclaration *>($package_decl)->_add_declaration_and_open_scope( );
  >>
  IS
  package_declarative_part[$package_decl->get_package_declarative_part()]
  END {PACKAGE_} 
  {
    simple_name > [end_name]
    <<check_name( package_name, end_name, "package" );>>
  } 
  SEMI_COLON
  <<
    dynamic_cast<IIRScram_PackageDeclaration *>($package_decl)->_type_check();
    my_symbol_table->close_scope( $package_decl );
  >>
;

package_declarative_part[IIR_DeclarationList *list ]:
  ( package_declarative_item[list] )*
;

package_declarative_item[IIR_DeclarationList *decl_list]:
  subprogram_declaration[ decl_list ]
| type_declaration[ decl_list ]
| subtype_declaration[ decl_list ]
| constant_declaration[ decl_list ]
| signal_declaration[ decl_list ]
| shared_variable_declaration[ decl_list ]
| file_declaration[ decl_list ]
| alias_declaration[ decl_list ]
| component_declaration[ decl_list ]
| attribute_declarative_item[ decl_list ]
| disconnection_specification[ decl_list ]
| use_clause[ decl_list ]
| (NATURE | SUBNATURE | TERMINAL)?
  <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
  ( nature_declaration[ decl_list ]
  | subnature_declaration[ decl_list ]
  | terminal_declaration[ decl_list ]
  )
| (GROUP IDENTIFIER COLON)? group_declaration[ decl_list ]
| group_template_declaration[ decl_list ]
;

package_body[ IIR_LibraryDeclaration *library ] > [ IIRScram_PackageBodyDeclaration *new_package_body ]:
  <<
    $new_package_body                   = NULL;
    IIRScram_Name            *end_name       = NULL;
    IIRScram_Identifier *    package_name    = NULL;
  >>
  package:PACKAGE_ BODY
  <<
    $new_package_body = new IIRScram_PackageBodyDeclaration();
    copy_location( package, $new_package_body );
  >>
  identifier > [ package_name ] 
  <<
    $new_package_body->set_declarator( package_name );
    dynamic_cast<IIRScram_PackageBodyDeclaration *>($new_package_body)->_add_declaration_and_open_scope( );

    IIRScram_PackageDeclaration *my_decl = NULL;
    my_decl = dynamic_cast<IIRScram_PackageDeclaration *>(library_manager::instance()->lookup_package( TRUE, 
                                                           package_name, 
                                                           library,
                                                           my_std_package,
                                                           my_factory));

    if( my_decl != NULL ){
      if( debug_symbol_table == true ){
	cerr << "Making package declaration |" << *dynamic_cast<IIRScram_Identifier *>(package_name) << "| visible." << endl;
      }
      dynamic_cast<IIRScram_PackageDeclaration *>(my_decl)->_make_interface_visible( my_symbol_table );
      my_decl->set_package_body( $new_package_body );
    }
    else{
      if( debug_symbol_table == true ){
	cerr <<"|" << *dynamic_cast<IIRScram_Identifier *>(package_name) << "| wasn't found." << endl;
      }
    } 
  >>
  IS
  package_body_declarative_part[ $new_package_body->get_package_declarative_part() ]
  END 
  { PACKAGE_ BODY } 
  {
    simple_name > [end_name]
    <<check_name( package_name, end_name, "package body");>>
  } 
  SEMI_COLON
  <<my_symbol_table->close_scope( $new_package_body );>>
;

package_body_declarative_part[IIR_DeclarationList *decl_list]:
  ( package_body_declarative_item[decl_list] )*
;

package_body_declarative_item[IIR_DeclarationList *decl_list]:
  subprogram[ decl_list ]
| type_declaration[ decl_list ]
| subtype_declaration[ decl_list ]
| constant_declaration[ decl_list ]
| shared_variable_declaration[ decl_list ]
| file_declaration[ decl_list ]
| alias_declaration[ decl_list ]
| use_clause[ decl_list ]
| (GROUP IDENTIFIER COLON)? group_declaration[ decl_list ]
| group_template_declaration[ decl_list ]
;

/* **********************************************************************

functions and procedures

********************************************************************** */

subprogram[ IIR_DeclarationList *list]:
  <<
    IIRScram_SubprogramDeclaration   *new_subp_decl          = NULL;
    IIR_Boolean                 added_declaration       = FALSE;
  >>     
  subprogram_header > [ new_subp_decl ]
  {
    subprogram_body[ new_subp_decl ]
    <<
      added_declaration = TRUE;
      IIRScram_TypeDefinition *return_type = NULL;
      // This will be NULL if the subprogram is a procedure.
      return_type = dynamic_cast<IIRScram_SubprogramDeclaration *>(new_subp_decl)->_get_subtype();
    
      IIR_Boolean found_return = 
	dynamic_cast<IIRScram_SubprogramDeclaration *>(new_subp_decl)->_type_check_return_statements( dynamic_cast<IIRScram_TypeDefinition *>(return_type) );
    
      if( new_subp_decl->get_kind() == IIR_FUNCTION_DECLARATION && found_return == FALSE ){
	ostringstream err;
	err << "No return statement found in subprogram "
	    << *dynamic_cast<IIRScram_TextLiteral *>(new_subp_decl->get_declarator());
	report_error( new_subp_decl, err.str(), WARNING );
      }
      dynamic_cast<IIRScram_SubprogramDeclaration *>(new_subp_decl)->_type_check();
      my_symbol_table->close_scope( new_subp_decl );
    >>
  } 
  SEMI_COLON
  <<
    list->append( new_subp_decl );
    if( added_declaration == FALSE ){
      my_symbol_table->add_subprogram_declaration( new_subp_decl, true );
      dynamic_cast<IIRScram_SubprogramDeclaration *>(new_subp_decl)->_type_check();
      my_symbol_table->close_scope( new_subp_decl );
    }
  >>
;

subprogram_declaration [IIR_DeclarationList *list]:
  <<IIRScram_SubprogramDeclaration *decl = NULL;>>
  subprogram_header > [decl] SEMI_COLON
  <<
    my_symbol_table->add_subprogram_declaration( decl, true );
    dynamic_cast<IIRScram_SubprogramDeclaration *>(decl)->_type_check();
    my_symbol_table->close_scope( decl );

    list->append( decl );
  >>
;

subprogram_header > [IIRScram_SubprogramDeclaration *retval]:
  <<
    $retval                                             = NULL;
    IIRScram_TextLiteral             *subp_name              = NULL;
    IIR_Pure                    purity                  = IIR_PURE_FUNCTION;
    IIRScram_TypeDefinition          *subp_return_type       = NULL;
    IIRScram_FunctionDeclaration     *fun_decl               = NULL;
    IIRScram_ProcedureDeclaration    *proc_decl              = NULL;
  >>
  procedure:PROCEDURE 
  <<
    proc_decl = new IIRScram_ProcedureDeclaration();
    copy_location( procedure, proc_decl );
  >>
  designator > [ subp_name ]
  <<proc_decl->set_declarator( subp_name );>>
  { L_PAREN formal_parameter_list[proc_decl->get_interface_declarations()] R_PAREN }
  <<$retval = proc_decl;>>
|
  { side_effects > [purity] }
  function:FUNCTION 
  designator > [ subp_name ]
  <<
    fun_decl = new IIRScram_FunctionDeclaration();
    fun_decl->set_declarator( subp_name );
    fun_decl->set_pure( purity );
    copy_location( function, fun_decl );
  >>
  { L_PAREN formal_parameter_list[fun_decl->get_interface_declarations()] R_PAREN }
  RETURN type_mark > [ subp_return_type ]
  <<
    fun_decl->set_return_type( subp_return_type );
    $retval = fun_decl;
  >>
;

side_effects > [IIR_Pure s]:
  PURE <<$s = IIR_PURE_FUNCTION;>>
| IMPURE <<$s = IIR_IMPURE_FUNCTION;>>
;

designator > [IIRScram_TextLiteral *retval]:
  <<$retval = NULL;>>
  identifier > [$retval]
| operator_symbol > [$retval]
;

operator_symbol > [IIRScram_StringLiteral *retval]:
  <<$retval = NULL;>>
  string_lit:STRING_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_StringLiteral*>(mytoken(string_lit)->getIIRPtr());
    dynamic_cast<IIRScram_StringLiteral *>($retval)->_to_lower();
    copy_location( string_lit, $retval );
  >>
;

formal_parameter_list[IIR_InterfaceList *list]:
  interface_list[ IIRScram_InterfaceDeclaration::PARAMETER_INTERFACE_LIST, $list]
;

subprogram_body[IIRScram_SubprogramDeclaration *subp_decl]:
  <<
    IIRScram_TextLiteral     *end_name               = NULL;
    const char               *function_or_procedure  = NULL;
  >>
  is:IS
  <<
    subp_decl->set_contains_body( TRUE );
    my_symbol_table->add_subprogram_declaration( subp_decl, true );
  
    if( subp_decl->get_kind() == IIR_PROCEDURE_DECLARATION ){
      function_or_procedure = "procedure";
    }
    else{
      ASSERT( subp_decl->get_kind() == IIR_FUNCTION_DECLARATION );
      function_or_procedure = "function"; 
    }
  >>
  subprogram_declarative_part[ $subp_decl->get_subprogram_declarations() ]
  BEGIN_
    sequence_of_statements[ $subp_decl->get_subprogram_body() ]
  END 
  { FUNCTION | PROCEDURE } 
  {
    designator > [end_name]
    <<
      ASSERT( subp_decl->get_declarator() != NULL );
      ASSERT( function_or_procedure != NULL );
      check_name( subp_decl->get_declarator(), end_name, function_or_procedure );
    >>
  }
;

subprogram_declarative_part[ IIR_DeclarationList *dl ]:
  ( subprogram_declarative_item[ $dl ] )*
;

subprogram_declarative_item[IIR_DeclarationList *decl_list ]:
  subprogram[ decl_list ]
| type_declaration[ decl_list ]
| subtype_declaration[ decl_list ]
| constant_declaration[ decl_list ]
| variable_declaration[ decl_list ]
| file_declaration[ decl_list ]
| alias_declaration[ decl_list ]
| attribute_declarative_item[ decl_list ]
| use_clause[ decl_list ]
;

signature > [IIRScram_Signature *retval]:
  <<
    $retval                             = NULL;
    IIRScram_TypeDefinition *type_def        = NULL;
    IIRScram_TypeDefinition *return_type     = NULL; 
  >>
  start:L_BRACKET 
  <<
    $retval = new IIRScram_Signature();
    copy_location( start, $retval );
  >>
  { 
    type_mark > [ type_def ]
    <<
      IIRScram_DesignatorExplicit *desig = new IIRScram_DesignatorExplicit();
      copy_location( type_def, desig );
      desig->set_name( type_def );
      $retval->get_argument_type_list()->append( desig );
    >>
    ( 
      COMMA type_mark > [ type_def ] 
      <<
        IIRScram_DesignatorExplicit *desig = new IIRScram_DesignatorExplicit();
        copy_location( type_def, desig );
        desig->set_name( type_def );
        $retval->get_argument_type_list()->append( desig );
      >>
    )*
  }
  { 
    RETURN type_mark >[return_type] 
    <<$retval->set_return_type( return_type );>>
  } 
  R_BRACKET 
;


/* **********************************************************************

specifications

********************************************************************** */

attribute_declarative_item[ IIR_DeclarationList *list ]:
  ATTRIBUTE 
  (
    attribute_declaration_tail[$list]
  |
    // Attribute specifications get placed into the declarative region
    // the "entity" (i.e., THING) they're associated with...
    attribute_specification_tail[$list]
  )
;

attribute_declaration_tail[IIR_DeclarationList *list]:
  <<
    IIRScram_AttributeDeclaration    *new_attribute_decl     = NULL;
    IIRScram_Identifier              *attribute_name         = NULL;
    IIRScram_TypeDefinition          *attribute_subtype      = NULL;
  >>
  <<new_attribute_decl = new IIRScram_AttributeDeclaration();>>
  identifier > [attribute_name] COLON
  type_mark > [attribute_subtype] SEMI_COLON
  <<
    copy_location( attribute_name, new_attribute_decl );
    new_attribute_decl->set_declarator( attribute_name );
    new_attribute_decl->set_subtype( attribute_subtype );
    list->append( new_attribute_decl );
    dynamic_cast<IIRScram_AttributeDeclaration *>(new_attribute_decl)->_add_declaration( );
  >>
;

attribute_specification_tail[IIR_DeclarationList *list]:
  <<
    IIRScram_AttributeSpecification  *new_attr               = NULL;
    IIRScram_Identifier              *attr_name              = NULL;
    IIR                         *attr_expression        = NULL;
  >>
  identifier > [attr_name]
  <<new_attr = new IIRScram_AttributeSpecification();>>
  of:OF
  entity_specification[ new_attr ] IS
  expression > [attr_expression] SEMI_COLON
  <<
    copy_location( of, new_attr );
    new_attr->set_declarator( attr_name );
    new_attr->set_value( attr_expression );
    list->append(new_attr);
    // Type checking happens after the whole declarative region has been sucked in.
  >>
;

attribute_specification[IIR_DeclarationList *list]:
  ATTRIBUTE attribute_specification_tail[$list]
;

entity_specification[ IIRScram_AttributeSpecification *new_attr ]:
  // Within this rule, we have to do the association between the
  // attribute and the "THINGS" it's associated with.  NOTE that
  // if the association is an OTHERS or ALL, than this is a forward
  // reference of sorts, and the "THINGS" that aren't declared at
  // this moment will need to get their attributes hooked on later.
  // Some mechanism to accomplish this needs to be developed!
  // Also, since the ability to regenerate functionally equivalent
  // VHDL is desired, the attribute specification will need to be
  // inserted into the declarative region of the "THING" it's 
  // associated with.
  <<
    IIRScram_Identifier *entity_class_identifier = NULL;
    constraint_functor *functor;
    IIR_Kind not_used;
  >>
  entity_name_list[new_attr->get_entity_name_list()] COLON 
  entity_class > [entity_class_identifier, not_used, functor]
  <<
    new_attr->set_entity_class( entity_class_identifier );
    dynamic_cast<IIRScram_AttributeSpecification *>(new_attr)->_set_entity_constraint( functor );
  >>
;

entity_name_list[IIR_DesignatorList *list]:
  <<
    IIRScram_Designator      *designator     = NULL;
    IIRScram_Signature       *sig            = NULL;
  >>
  entity_designator > [designator]
  <<$list->append( designator );>>
  {
    signature > [sig]
    <<
      if( designator->get_kind() != IIR_DESIGNATOR_EXPLICIT ){
	ostringstream err;
	err << "Non-explicit designators may not have signatures.";
	report_error( sig, err.str() );
      }
      else{
	dynamic_cast<IIRScram_DesignatorExplicit *>(designator)->set_signature( sig );
      }
    >>
  }
  (
    COMMA
    entity_designator > [designator]
    {
      signature > [sig]
      <<
        if( designator->get_kind() != IIR_DESIGNATOR_EXPLICIT ){
	  ostringstream err;
	  err << "Non-explicit designators may not have signatures.";
	  report_error( sig, err.str() );
	}
	else{
	  dynamic_cast<IIRScram_DesignatorExplicit *>(designator)->set_signature( sig );
	}
      >>
    }
    <<$list->append( designator );>>
  )* 
| others:OTHERS
  <<
    designator = new IIRScram_DesignatorByOthers();
    $list->append( designator );
    copy_location( others, designator );
  >>
| all:ALL 
  <<
    designator = new IIRScram_DesignatorByAll();
    $list->append( designator );
    copy_location( all, designator );
  >>
;

entity_designator > [IIRScram_DesignatorExplicit *retval]:
  <<
    $retval = NULL;
    IIRScram *name = NULL;
  >>        
  <<$retval = new IIRScram_DesignatorExplicit();>>
  simple_name > [ name ]
  <<
    copy_location( name, $retval );
    $retval->set_name( name );
  >>
| <<$retval = new IIRScram_DesignatorExplicit();>>
  operator_symbol > [ name ]
  <<
    copy_location( name, $retval );
    $retval->set_name( name );
  >>
;

entity_class > [ IIRScram_Identifier *identifier_part,
		 IIR_Kind kind_part,
		 constraint_functor *functor ]:
  <<$identifier_part = NULL;>>
  ent:ENTITY 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>(IIRScram_Identifier::get( "entity", 6, my_factory)); 
    $kind_part = IIR_ENTITY_DECLARATION;
    $functor = new is_entity_declaration_functor();
  >>
| arc:ARCHITECTURE 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>(IIRScram_Identifier::get("architecture", 12, my_factory)); 
    $kind_part = IIR_ARCHITECTURE_DECLARATION;
    $functor = new is_architecture_declaration_functor();
  >>
| conf:CONFIGURATION 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>(IIRScram_Identifier::get("configuration", 13, my_factory)); 
    $kind_part = IIR_CONFIGURATION_DECLARATION;
    $functor = new is_configuration_declaration_functor();
  >>
| pro:PROCEDURE 
  <<
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>(IIRScram_Identifier::get( "procedure", 9, my_factory)); 
    $kind_part = IIR_PROCEDURE_DECLARATION;
    $functor = new is_procedure_declaration_functor();
  >>
| fun:FUNCTION 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>(IIRScram_Identifier::get( "function", 8, my_factory));
    $kind_part = IIR_FUNCTION_DECLARATION;
    $functor = new is_function_declaration_functor();
  >>
| pac:PACKAGE_ 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "package", 7, my_factory));
    $kind_part = IIR_PACKAGE_DECLARATION;
    $functor = new is_package_declaration_functor();
  >>
| typ:TYPE 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "type", 4, my_factory));
    $kind_part = IIR_TYPE_DECLARATION;
    $functor = new is_type_functor();
  >>
| sub:SUBTYPE 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "subtype", 7, my_factory));
    $kind_part = IIR_SUBTYPE_DECLARATION;
    $functor = new is_subtype_declaration_functor();
  >>
| con:CONSTANT 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "constant", 8, my_factory));
    $kind_part = IIR_CONSTANT_DECLARATION;
    // There are several "constant" nodes
    $functor = new is_constant_functor();
  >>
| sig:SIGNAL 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "signal", 6, my_factory));
    $kind_part = IIR_SIGNAL_DECLARATION;
    // There are several "signal" nodes
    $functor = new is_signal_functor();
  >>
| var:VARIABLE 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "variable", 8, my_factory));
    $kind_part = IIR_VARIABLE_DECLARATION;
    // There are several "variable" nodes
    $functor = new is_variable_functor();
  >>
| com:COMPONENT 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "component", 9, my_factory));
    $kind_part = IIR_COMPONENT_DECLARATION;
    $functor = new is_component_declaration_functor();
  >>
| lab:LABEL 
  << 
    $identifier_part =
       dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "label", 5, my_factory)); 
    $kind_part = IIR_LABEL;
    $functor = new is_label_functor();
  >>
| lit:LITERAL 
  << 
    $identifier_part =
dynamic_cast<IIRScram_Identifier *>(IIRScram_Identifier::get( "literal", 7, my_factory)); 
    $kind_part = IIR_LITERAL;
    // There are several "literal" nodes
    $functor = new is_literal_functor();
  >>
| uni:UNITS 
  << 
    $identifier_part =
       dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "units", 5, my_factory));
    $kind_part = IIR_PHYSICAL_UNIT;
    $functor = new is_physical_unit_functor();
  >>
| gro:GROUP 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "group", 5, my_factory));
    $kind_part = IIR_GROUP_DECLARATION;
    $functor = new is_group_declaration_functor();
  >>
| fil:FILE_ 
  << 
    $identifier_part =
      dynamic_cast<IIRScram_Identifier *>( IIRScram_Identifier::get( "file", 4, my_factory)); 
    $kind_part = IIR_FILE_DECLARATION;
    // There are several "file" nodes
    $functor = new is_file_functor();
  >>
| <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
  ( nature:NATURE
  | subnature:SUBNATURE
  | quantity:QUANTITY
  | terminal:TERMINAL
  )
;

configuration_specification[IIR_DeclarationList *list]:
  <<
    IIR                                 *component_name         = NULL;
    IIRScram_ConfigurationSpecification      *configuration_spec     = NULL;
    scram_binding_info_t                *binding_info           = NULL;
  >>
  for_:FOR 
  <<
    configuration_spec = new IIRScram_ConfigurationSpecification();
    copy_location( for_, configuration_spec );
  >>
  component_specification[ configuration_spec->get_instantiation_list() ] > [ component_name ]
  <<configuration_spec->set_component_name( component_name );>>
  binding_indication > [ binding_info ] SEMI_COLON
  <<
    ASSERT( binding_info != NULL );
    configuration_spec->set_entity_aspect( binding_info->entity_aspect );
    if( binding_info->generic_map_aspect != NULL ){
      if( binding_info->generic_map_aspect->size() > 0 ){
	configuration_spec->set_generic_map_aspect(binding_info->generic_map_aspect);
      }
    }
    if( binding_info->port_map_aspect != NULL ){
      if( binding_info->port_map_aspect->size() > 0 ){
	configuration_spec->set_port_map_aspect(binding_info->port_map_aspect);
      }
    }
    // configuration specficiations can't be type checked until after all
    // of the statements in their containing declarative region have been
    // parsed, because we can provide specifications for labels that haven't
    // been (implicitly) declared yet.
    list->append( configuration_spec );
  >>
;

component_specification[ IIR_DesignatorList *list ] > [ IIRScram_Name *name ]:
  <<$name = NULL;>>
  instantiation_list[ list ] COLON complex_name > [ $name ]
;

instantiation_list[ IIR_DesignatorList *list]:
  <<
    IIRScram_DesignatorExplicit      *designator_explicit    = NULL;
    IIRScram_Designator              *designator             = NULL;
    IIRScram_Name                    *component_name         = NULL;
  >>
  simple_name > [ component_name ] 
  <<
    designator_explicit = new IIRScram_DesignatorExplicit();
    copy_location( component_name, designator_explicit );
    designator_explicit->set_name( component_name );
    list->append( designator_explicit );
  >>
  (
    COMMA 
    simple_name > [ component_name ] 
    <<
      designator_explicit = new IIRScram_DesignatorExplicit();
      copy_location( component_name, designator_explicit );
      designator_explicit->set_name( component_name );
      list->append( designator_explicit );
    >>
  )*
| others:OTHERS
  <<
    designator = new IIRScram_DesignatorByOthers();
    copy_location( others,  designator );
    list->append( designator );
  >>
| all:ALL
  <<
    designator = new IIRScram_DesignatorByAll();
    copy_location( all,  designator );
    list->append( designator );
  >>
;

binding_indication > [scram_binding_info_t *binding_info ]:
  <<$binding_info = NULL;>>
  {
    <<$binding_info = new scram_binding_info_t();>>
    USE entity_aspect > [$binding_info->entity_aspect]
  }
  {
    <<$binding_info->generic_map_aspect = new IIRScram_AssociationList();>>
    generic_map_aspect[$binding_info->generic_map_aspect]
  }
  {
    <<$binding_info->port_map_aspect = new IIRScram_AssociationList();>>
    port_map_aspect[$binding_info->port_map_aspect]
  }
;

// This rule returns the library unit (entity/architecture pair,
// configuration, or NULL ) associated with the calling rule.
entity_aspect > [IIRScram_LibraryUnit *lib_unit]:
  <<
    $lib_unit = NULL;
    IIRScram_Name            *entity_name            = NULL;
    IIRScram_SimpleName      *arch_name              = NULL;
    IIRScram_Name            *configuration_name     = NULL;
  >>
  entity:ENTITY 
  selected_or_simple_name > [entity_name]
  <<
    if( entity_name != NULL ){
      $lib_unit = dynamic_cast<IIRScram_LibraryUnit *>(library_manager::instance()->lookup_entity( TRUE, 
	        				              entity_name,
						              dynamic_cast<IIRScram_Name *>(entity_name)->_get_work_library(),
                                                              my_std_package,
                                                              my_factory));
    }
  >>
  {
    L_PAREN
    simple_name > [arch_name]
    <<
      if( $lib_unit != NULL ){
        ASSERT( dynamic_cast<IIRScram_LibraryUnit *>($lib_unit)->is_entity_declaration() == TRUE );
	$lib_unit = dynamic_cast<IIRScram_LibraryUnit *>(library_manager::instance()->lookup_architecture( TRUE, 
                                                                                                      dynamic_cast<IIRScram_EntityDeclaration *>($lib_unit),
                                                                                                      arch_name));
      }
    >>
    R_PAREN
  }
| configuration:CONFIGURATION
  complex_name > [configuration_name]
  <<
    if( configuration_name != NULL ){
      $lib_unit = dynamic_cast<IIRScram_LibraryUnit *>(
        library_manager::instance()->lookup_configuration( TRUE, 
							   configuration_name,
							   dynamic_cast<IIRScram_Name *>(configuration_name)->_get_work_library(),
                                                           my_std_package,
                                                           my_factory));
    }
  >>
| open:OPEN
  <<$lib_unit = NULL;>>
;

generic_map_aspect[IIR_AssociationList *alist]:
  generic:GENERIC MAP <<copy_location( generic, $alist );>>
  L_PAREN association_list_in[$alist] R_PAREN
;

port_map_aspect[IIR_AssociationList *alist]:
  port:PORT MAP<<copy_location( port, $alist );>>
  L_PAREN association_list_in[$alist] R_PAREN
;

disconnection_specification[IIR_DeclarationList *list]:
  <<
    IIR_DesignatorList  *signal_list            = NULL;
    IIRScram_TypeDefinition  *signal_type            = NULL;
    IIR                 *time_expression        = NULL;
  >>
  disconnect:DISCONNECT 
  guarded_signal_specification > [signal_list, signal_type]
  AFTER
  expression > [ time_expression ] SEMI_COLON
  <<
    IIRScram_DisconnectSpecification *new_spec = new IIRScram_DisconnectSpecification();
    copy_location( disconnect, new_spec );

    new_spec->set_type_mark( signal_type );
    new_spec->set_time_expression( time_expression );
    new_spec->set_guarded_signal_list(dynamic_cast<IIRScram_DesignatorList *>(IIRScram_List::_listcopy(dynamic_cast<IIRScram_List *>(signal_list), my_factory )));
    list->append( new_spec );
  >>
;

guarded_signal_specification> [ IIR_DesignatorList *name_list, IIRScram_TypeDefinition *signal_type ]:
  <<
    $name_list = NULL;
    $signal_type = NULL;
  >>
  signal_list > [ $name_list ] COLON
  type_mark > [ $signal_type ]
;

signal_list > [IIR_DesignatorList *return_list]:
  <<
    $return_list                                        = NULL;
    IIR                         *name                   = NULL;
    IIRScram_DesignatorExplicit      *sig_name_explicit      = NULL;
    IIRScram_DesignatorByOthers      *sig_name_others        = NULL;
    IIRScram_DesignatorByAll         *sig_name_all           = NULL;
  >>
  complex_name > [name] 
  <<
    $return_list = new IIRScram_DesignatorList();
    sig_name_explicit = new IIRScram_DesignatorExplicit();
    copy_location( name, sig_name_explicit );
    sig_name_explicit->set_name( name );
    $return_list->append( sig_name_explicit );
  >>
  (
    COMMA complex_name > [ name ] 
    <<
     sig_name_explicit = new IIRScram_DesignatorExplicit();
     copy_location( name, sig_name_explicit );
     sig_name_explicit->set_name( name );
     $return_list->append( sig_name_explicit );
    >>
  )*
| others:OTHERS 
  <<
    sig_name_others = new IIRScram_DesignatorByOthers();
    $return_list->append( sig_name_others );
    copy_location( others,  $return_list );
  >>
| all:ALL
  <<
    sig_name_all = new IIRScram_DesignatorByAll();
    $return_list->append( sig_name_all );
    copy_location( all,  $return_list );
  >>
;

/* **********************************************************************

scoping

********************************************************************** */

use_clause[ IIR_DeclarationList *list ]:
  <<
    IIRScram_Name *name = NULL;
    IIRScram_UseClause *new_clause = NULL;
  >>
  use:USE
  <<
    new_clause = new IIRScram_UseClause();
    copy_location( use, new_clause );
  >>
  complex_name > [name] 
  <<
    new_clause->set_selected_name( name );
    list->append( new_clause );
    dynamic_cast<IIRScram_UseClause *>(new_clause)->_type_check();
  >>
  (
    comma:COMMA selected_name > [ name ] 
    <<
      new_clause = new IIRScram_UseClause();
      copy_location( comma, new_clause );

      new_clause->set_selected_name( name );
      list->append( new_clause );
      dynamic_cast<IIRScram_UseClause *>(new_clause)->_type_check();
    >>
  )*
  SEMI_COLON
;

/* **********************************************************************

type definitions

********************************************************************** */

scalar_type_definition[ IIRScram_TypeDeclaration *type_decl ] > [IIRScram_ScalarTypeDefinition *retval]:
  <<
    $retval                                             = NULL;
    IIRScram_PhysicalTypeDefinition  *new_physical_type      = NULL;
    IIRScram_ScalarTypeDefinition    *new_range_type         = NULL;
  >>
  enumeration_type_definition[ type_decl ] > [ $retval ]
| range_constraint > [new_range_type] 
  <<
    if( new_range_type->get_kind() == IIR_RANGE_TYPE_DEFINITION ){
      IIRScram_RangeTypeDefinition *temp = dynamic_cast<IIRScram_RangeTypeDefinition *>(new_range_type);
      $retval = dynamic_cast<IIRScram_ScalarTypeDefinition *>(IIRScram_TypeDefinition::_construct_new_type( dynamic_cast<IIRScram_RangeTypeDefinition *>(temp), 
                                                                                                       dynamic_cast<IIRScram_TypeDeclaration *>(type_decl), 
                                                                                                       dynamic_cast<IIRScram_DesignFile *>(my_design_file) ));
    }
    else{
      $retval = new_range_type;
    }
  >>
  { 
    physical_type_definition > [new_physical_type]
    <<
      new_physical_type->set_left( $retval->get_left());
      new_physical_type->set_direction( $retval->get_direction());
      new_physical_type->set_right( $retval->get_right());
      new_physical_type->set_declaration( type_decl );
      ASSERT( dynamic_cast<IIRScram_PhysicalTypeDefinition *>(new_physical_type)->_get_base_type() != NULL );
      dynamic_cast<IIRScram_PhysicalTypeDefinition *>(new_physical_type)->_get_base_type()->set_declaration( type_decl );      
      $retval = new_physical_type;
    >>
  }
;

enumeration_type_definition[ IIRScram_TypeDeclaration *type_decl ] > [ IIRScram_EnumerationSubtypeDefinition *retval ]:
  <<
    IIRScram_EnumerationLiteral      *lit = NULL;
    IIRScram_EnumerationLiteralList  *literals = new IIRScram_EnumerationLiteralList();
  >>
  info:L_PAREN
  enumeration_literal > [lit] <<literals->append(lit);>>
  ( COMMA enumeration_literal > [lit] <<literals->append(lit);>> )*
  R_PAREN
  <<$retval = IIRScram_EnumerationTypeDefinition::_construct_new_type( dynamic_cast<IIRScram_EnumerationLiteralList *>(literals), dynamic_cast<IIRScram_TypeDeclaration *>(type_decl), dynamic_cast<IIRScram_DesignFile *>(my_design_file) );>>
;

enumeration_literal > [IIRScram_EnumerationLiteral *retval]:
  <<
    $retval = NULL;
    IIRScram_Identifier *id = NULL;
  >>
  identifier > [ id ]
  <<
    $retval = new IIRScram_EnumerationLiteral();
    $retval->set_declarator( id );
    copy_location( id, $retval );
  >>
| char_lit:CHARACTER_LITERAL
  <<
    $retval = new IIRScram_EnumerationLiteral();
    copy_location( char_lit, $retval );
    $retval->set_declarator(dynamic_cast<IIRScram_CharacterLiteral*>(mytoken(char_lit)->getIIRPtr()));
  >>
;

range_constraint > [ IIRScram_ScalarTypeDefinition *s]:
  <<$s = NULL;>>
  range_:RANGE range > [$s]
;

range > [ IIRScram_ScalarTypeDefinition *retval ]: 
  <<
    $retval                             = NULL;
    IIR                 *left           = NULL;
    IIR                 *dir            = NULL;
    IIR                 *right          = NULL;
    IIRScram_Name            *prefix         = NULL;
    IIRScram_Attribute       *range_attr     = NULL;
  >>
  (
    (
      selected_name > [prefix] QUOTE 
      (
        attribute_range[ prefix ] > [ range_attr ]
      | attribute_reverse_range[ prefix ] > [ range_attr ]  
      )
    )
    <<
      $retval = dynamic_cast<IIRScram_Attribute *>(range_attr)->_build_range_type();
      delete range_attr;
    >>
  )?
| simple_expression > [left] direction > [dir] simple_expression > [right]
  <<
    $retval = new IIRScram_RangeTypeDefinition();
    copy_location( dir, $retval );
    $retval->set_left( left );
    $retval->set_direction( dir );
    $retval->set_right( right );
  >>     
;

physical_type_definition > [IIRScram_PhysicalTypeDefinition *pt]:
  <<
    $pt                                         = NULL;
    IIRScram_PhysicalTypeDefinition *base_type  = NULL;
    IIRScram_PhysicalUnit    *base_unit              = NULL;
    IIRScram_Identifier      *base_unit_identifier   = NULL;
    IIRScram_Name            *end_name               = NULL;
  >>
  units_:UNITS
  <<
    base_type = new IIRScram_PhysicalTypeDefinition();
    $pt = new IIRScram_PhysicalSubtypeDefinition();

    $pt->set_base_type( base_type );
    copy_location( units_, $pt );
    copy_location( units_, base_type );
  >>
  base_unit_declaration > [base_unit_identifier]
  <<
    base_unit = new IIRScram_PhysicalUnit();
    copy_location( base_unit_identifier, base_unit );
    base_unit->set_declarator(base_unit_identifier);
    dynamic_cast<IIRScram_PhysicalUnit *>(base_unit)->set_subtype( dynamic_cast<IIRScram_PhysicalTypeDefinition *>($pt) );
    dynamic_cast<IIRScram_PhysicalUnit *>(base_unit)->_add_declaration( );    

    IIRScram_IntegerLiteral *unity = new IIRScram_IntegerLiteral();
    dynamic_cast<IIRScram_IntegerLiteral *>(unity)->set_mantissa("1", 1);
    base_unit->set_multiplier( unity );
    dynamic_cast<IIRScram_IntegerLiteral *>(unity)->set_subtype( $pt );
    base_type->set_primary_unit( base_unit );
  >>
  ( secondary_unit_declaration[ $pt->get_units() ] )*
  <<
    IIRScram_PhysicalUnit *current_unit = NULL;
    current_unit = dynamic_cast<IIRScram_PhysicalUnit *>($pt->get_units()->first());
    while( current_unit != NULL ){
      dynamic_cast<IIRScram_PhysicalUnit *>(current_unit)->set_subtype( dynamic_cast<IIRScram_PhysicalTypeDefinition *>( $pt ) );
      ASSERT( current_unit->get_multiplier() != NULL &&
	      current_unit->get_multiplier()->get_kind() == IIR_PHYSICAL_LITERAL );
      dynamic_cast<IIRScram_PhysicalLiteral *>(current_unit->get_multiplier())->set_subtype( $pt );
      current_unit = current_unit = dynamic_cast<IIRScram_PhysicalUnit *>($pt->get_units()->successor( current_unit ) );
    }
  >>
  END UNITS 
  { 
    simple_name > [end_name] 
    <<
      // Need to check this against the type declaration...
      // check_name( base_unit_identifier, end_name, "unit" );
    >>
  }
;

base_unit_declaration > [IIRScram_Identifier *bu]:
  <<$bu = NULL;>>
  identifier > [$bu] SEMI_COLON
;

secondary_unit_declaration[ IIR_UnitList *list ]:
  <<
    IIRScram_PhysicalUnit    *new_unit               = NULL;
    IIRScram_Identifier      *unit_identifier        = NULL;
    IIRScram_PhysicalLiteral *new_physical_literal   = NULL;
  >>
  identifier > [unit_identifier]
  equal_:EQUAL
  physical_literal > [new_physical_literal] SEMI_COLON
  <<
    new_unit = new IIRScram_PhysicalUnit();
    copy_location( equal_, new_unit );
    new_unit->set_declarator(unit_identifier);
    new_unit->set_multiplier(new_physical_literal);
    list->append(new_unit);
    dynamic_cast<IIRScram_PhysicalUnit *>(new_unit)->_add_declaration();
  >>
;

physical_literal > [IIRScram_PhysicalLiteral *pl]:
  <<
    $pl                                 = NULL;
    IIR                 *numeric_value  = NULL;
    IIRScram_SimpleName      *unit_name      = NULL;
  >>
  <<$pl = new IIRScram_PhysicalLiteral();>>
  { integer_literal > [numeric_value] <<$pl->set_abstract_literal(numeric_value);>> }
  simple_name > [unit_name]
  <<
    copy_location( unit_name, $pl );
    constraint_functor *functor = new is_physical_unit_functor();
    savant::set<IIRScram_Declaration*> *unit_decls =
      dynamic_cast<IIRScram_SimpleName *>(unit_name)->IIRScram_Name::_symbol_lookup(functor);
    delete functor;
    if( unit_decls == NULL ){
      report_undefined_symbol( unit_name );
    }
    else{
      switch( unit_decls->size() ){
      case 0:{
        report_undefined_symbol( unit_name );
        break;
      }
      case 1:{
        ASSERT( *unit_decls->begin() != NULL );
        $pl->set_unit_name( dynamic_cast<IIRScram_PhysicalUnit *>(*unit_decls->begin()) );
        break;
      }
      default:{
	cerr << "Internal error in VHDLParser::physical_literal" << endl;
	abort();
      }
      }
    }
    delete unit_decls;
  >>
;

abstract_literal > [IIRScram_Literal *literal]:
  <<$literal = NULL;>>
  integer_literal > [$literal]
| real_literal > [$literal]
;

composite_type_definition[ IIRScram_TypeDeclaration *type_decl ] > [IIRScram_TypeDefinition *retval]:
  array_type_definition[ type_decl ] > [$retval]
| record_type_definition > [$retval]
;

array_type_definition[ IIRScram_TypeDeclaration *type_decl ] > [IIRScram_ArrayTypeDefinition *retval]:
  <<
    $retval = NULL;
    IIRScram_ScalarTypeDefinition    *index_subtype = NULL;
    IIRScram_TypeDefinition          *element_subtype = NULL;
    IIRScram_ArrayTypeDefinition     *prev_subtype = NULL;
    IIRScram_ArrayTypeDefinition     *final_subtype = NULL;
    IIR_Boolean                 is_unconstrained = false;
    IIR_Boolean                 err_flag = false;
  >>
  array:ARRAY
  L_PAREN 
  array_dimension > [index_subtype]
  <<
    $retval = IIRScram_ArrayTypeDefinition::_construct_array_type( dynamic_cast<IIRScram_ScalarTypeDefinition *>(index_subtype), NULL, dynamic_cast<IIRScram_TypeDeclaration *>(type_decl) );
    if( dynamic_cast<IIRScram_ArrayTypeDefinition *>($retval)->is_unconstrained_array_type() ){
      is_unconstrained = TRUE;
    }
    copy_location( array,  $retval );
    final_subtype = $retval;
  >>
  (
    COMMA  
    array_dimension > [index_subtype]
    <<
      prev_subtype = final_subtype;
      final_subtype = IIRScram_ArraySubtypeDefinition::_construct_array_type( dynamic_cast<IIRScram_ScalarTypeDefinition *>(index_subtype), NULL, NULL );
      dynamic_cast<IIRScram_ArrayTypeDefinition *>(prev_subtype)->set_element_subtype( final_subtype );
      ASSERT( prev_subtype->get_base_type() != NULL );
      ASSERT( dynamic_cast<IIRScram_ArrayTypeDefinition *>(prev_subtype->get_base_type())->_is_iir_array_type_definition() == TRUE );
      dynamic_cast<IIRScram_ArrayTypeDefinition *>(prev_subtype->get_base_type())->set_element_subtype( final_subtype );
      if( is_unconstrained == TRUE ){
	if( dynamic_cast<IIRScram_ArrayTypeDefinition *>(final_subtype)->is_unconstrained_array_type() == FALSE ){
	  err_flag = TRUE;
	}
      }
      else{
	if( dynamic_cast<IIRScram_ArrayTypeDefinition *>(final_subtype)->is_unconstrained_array_type() == TRUE ){
	  err_flag = TRUE;	
	}
      }

      if( err_flag == TRUE ){
	ostringstream err;
	err << "All indexes of an array must be either constrained or unconstrained."
	    << " They cannot be mixed.";
	report_error( index_subtype, err.str() );
      }
    >>
  )*
  R_PAREN
  OF
  subtype_indication > [element_subtype]
  <<
    if( dynamic_cast<IIRScram_TypeDefinition *>(element_subtype)->is_array_type() == TRUE ){
      dynamic_cast<IIRScram_TypeDefinition *>(element_subtype)->set_is_element( TRUE );
    }

    dynamic_cast<IIRScram_ArrayTypeDefinition *>(final_subtype)->set_element_subtype( element_subtype );
    if( dynamic_cast<IIRScram_ArrayTypeDefinition *>(final_subtype)->_get_base_type() != NULL ){
      ASSERT( dynamic_cast<IIRScram_ArrayTypeDefinition *>(final_subtype)->_get_base_type()->_is_iir_array_type_definition() == TRUE );
      (dynamic_cast<IIRScram_ArrayTypeDefinition *>(final_subtype->get_base_type()))->set_element_subtype( element_subtype );
    }
  >>
;

array_dimension > [ IIRScram_ScalarTypeDefinition *retval]:
  <<
    $retval = NULL;
    IIRScram_ScalarTypeDefinition *temp_range = NULL;
  >>
  (index_subtype_definition > [$retval])?
| (discrete_range > [temp_range])
  <<
    if( temp_range != NULL && temp_range->get_kind() == IIR_RANGE_TYPE_DEFINITION ){
      $retval =
	IIRScram_ArrayTypeDefinition::_build_proper_index( dynamic_cast<IIRScram_RangeTypeDefinition *>(temp_range) );
      // delete temp_range;
    }
    else{
      $retval = temp_range;
    }
  >>
;

index_subtype_definition > [IIRScram_ScalarTypeDefinition *retval]:
  <<
    $retval = NULL;
    IIRScram_TypeDefinition *type_designator = NULL;
  >>
  type_mark > [type_designator]
  <<
    if( dynamic_cast<IIRScram_TypeDefinition *>(type_designator)->is_scalar_type() != TRUE ||
	dynamic_cast<IIRScram_TypeDefinition *>(type_designator)->is_discrete_type() != TRUE ){
      ostringstream err;
      err << "Array indexes must be discrete, scalar, types.";
      report_error( type_designator, err.str() );
      $retval = NULL;
    }
  >>
  RANGE
  start:LESS_GREATER
  <<
    IIRScram_RangeTypeDefinition *temp_range = new IIRScram_RangeTypeDefinition();
    copy_location( start, temp_range );

    temp_range->set_left( NULL );
    temp_range->set_right( NULL );
    temp_range->set_direction( NULL );
    IIRScram_TypeDefinition *subtype = NULL;
    subtype = dynamic_cast<IIRScram_TypeDefinition *>(type_designator)->_construct_new_subtype( NULL, dynamic_cast<IIRScram_RangeTypeDefinition *>(temp_range) );
    dynamic_cast<IIRScram_TypeDefinition *>(subtype)->set_type_mark( type_designator );

    ASSERT( dynamic_cast<IIRScram_TypeDefinition *>(subtype)->is_scalar_type() == TRUE );
    $retval = dynamic_cast<IIRScram_ScalarTypeDefinition *>(subtype);

    copy_location( start, $retval );
    delete temp_range;
  >>
;

record_type_definition > [IIRScram_RecordTypeDefinition *decl]:
  <<
    $decl = NULL;
    IIRScram_Name *end_label = NULL;
  >>
  record:RECORD
  <<
    $decl = new IIRScram_RecordTypeDefinition();
    copy_location( record, $decl );
    my_symbol_table->open_scope( $decl );
  >>
  ( element_declaration[$decl->get_element_declarations()] )+
  <<
    my_symbol_table->add_declaration( $decl->get_element_declarations() );
    my_symbol_table->close_scope( $decl );
  >>
  END RECORD {simple_name > [end_label]}
;

element_declaration[IIR_ElementDeclarationList *decl_list]:
  <<
    IIRScram_ElementDeclaration      *decl           = NULL;
    IIR_Identifier                   *id             = NULL;
    IIRScram_TypeDefinition          *elem_subtype   = NULL;
    IIR_IdentifierList               *id_list        = NULL;
  >>
  <<id_list = new IIRScram_IdentifierList();>>
  identifier_list[id_list] 
  colon:COLON
  subtype_indication > [elem_subtype] SEMI_COLON
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      decl = new IIRScram_ElementDeclaration();
      copy_location( id, decl );
      decl->set_declarator(id);
      decl->set_subtype(elem_subtype);
      $decl_list->append(decl);

      // need to remove instead of taking successor because current 
      // linked list class does not process duplicate members
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
  >>
;

access_type_definition[ IIRScram_TypeDeclaration *type_decl ] > [IIRScram_AccessTypeDefinition *new_access_type]:
  <<
    $new_access_type = NULL;
    IIRScram_TypeDefinition *type_def = NULL;
  >>
  access:ACCESS subtype_indication > [type_def]
  <<
    $new_access_type = IIRScram_AccessTypeDefinition::_construct_new_type( dynamic_cast<IIRScram_TypeDefinition *>(type_def), dynamic_cast<IIRScram_TypeDeclaration *>(type_decl), dynamic_cast<IIRScram_DesignFile *>(my_design_file) );
    copy_location(  access, $new_access_type );
  >>
;

file_type_definition > [IIRScram_FileTypeDefinition *new_file_type]:
  <<
    $new_file_type = NULL;
    IIRScram_TypeDefinition *type_def = NULL;
  >>
  file_:FILE_ OF
  <<
    $new_file_type = new IIRScram_FileTypeDefinition();
    copy_location( file_, $new_file_type );
  >>
  type_mark > [type_def] <<$new_file_type->set_type_mark(type_def);>>
;

/* **********************************************************************

declarations

********************************************************************** */

type_declaration[IIR_DeclarationList *list]:
  <<
    IIRScram_TypeDeclaration         *old_incomplete_type    = NULL;
    IIRScram_Identifier              *type_name              = NULL;
    IIRScram_TypeDeclaration         *type_decl              = NULL;
    IIRScram_TypeDefinition          *new_definition         = NULL;
  >>
  type:TYPE identifier > [type_name]
  <<
    old_incomplete_type = dynamic_cast<IIRScram_TypeDeclaration *>(find_incomplete_type_declaration( type_name ));
    type_decl = new IIRScram_TypeDeclaration();
    type_decl->set_declarator( type_name );
    copy_location( type, type_decl );
  >>
  {
    IS type_definition[ type_decl ] > [new_definition]
    <<
      new_definition->set_declaration( type_decl );
      type_decl->set_type( new_definition );
    >>
  }
  SEMI_COLON
  <<
    if( type_decl->get_type() == NULL ){
      IIRScram_IncompleteTypeDefinition *incomplete_type = new IIRScram_IncompleteTypeDefinition();
      incomplete_type->set_designated_type_name( dynamic_cast<IIRScram_Identifier *>(type_name) );	
      type_decl->set_type( incomplete_type );
    }
    if( old_incomplete_type != NULL ){
      my_symbol_table->incomplete_type_fixup( old_incomplete_type, type_decl );
      // This was screwing up the case:
      // type a;
      // type a is access a;
      //       delete old_incomplete_type->get_type();
      old_incomplete_type->set_type( NULL );
    }

    list->append( type_decl );
    dynamic_cast<IIRScram_TypeDeclaration *>(type_decl)->_add_declaration();
  >>
;

type_definition[ IIRScram_TypeDeclaration *type_decl ] > [IIRScram_TypeDefinition *s]:
  <<$s = NULL;>>
  scalar_type_definition[ type_decl ] > [$s]
| composite_type_definition[ type_decl ] > [$s]
| access_type_definition[ type_decl ] > [$s]
| file_type_definition > [$s]
| (PROTECTED BODY)? 
  <<lang_proc->processing_vhdl_2001()>>?
    [lang_proc->report_not_vhdl_2001((ANTLRToken *)LT(1));]
    protected_type_body[type_decl] > [$s]
| <<lang_proc->processing_vhdl_2001()>>?
    [lang_proc->report_not_vhdl_2001((ANTLRToken *)LT(1));]
    protected_type_declaration[type_decl] > [$s]
;

subtype_declaration[ IIR_DeclarationList *list ]:
  <<
    IIRScram_TypeDefinition          *type_definition        = NULL;
    IIRScram_Identifier              *subtype_name           = NULL;
    IIRScram_SubtypeDeclaration      *new_subtype_decl       = NULL;
  >>
  subtype:SUBTYPE
  <<
    new_subtype_decl = new IIRScram_SubtypeDeclaration();
    copy_location( subtype, new_subtype_decl );
  >>
  identifier > [subtype_name] IS subtype_indication > [type_definition] SEMI_COLON
  <<
    if( type_definition->get_declaration() == NULL ){
      // Then, this is indeed a new type.
      type_definition->set_declaration( new_subtype_decl );
    }
    else{
      // This wasn't a new type - it was soemthing like:
      // subtype foo is bar;
      // The LRM says "the subtype is the same as the type."  We're
      // going to copy the subtype for convenience - hopefully we're
      // not violating any semantics...
      IIRScram_TypeDefinition *temp_type = dynamic_cast<IIRScram_TypeDefinition *>(type_definition)->_construct_new_subtype( 0, 0 );
      temp_type->set_type_mark( type_definition );
      temp_type->set_declaration( new_subtype_decl );
      type_definition = temp_type;
    }
    new_subtype_decl->set_declarator( subtype_name );
    new_subtype_decl->set_subtype( type_definition );
    list->append( new_subtype_decl );
    dynamic_cast<IIRScram_SubtypeDeclaration *>(new_subtype_decl)->_add_declaration();
  >>
;

// This rule needs to create a new SubtypeDefinition with an IIRScram_TypeDefinition
// or IIRScram_SubtypeDefinition base.  The possibilities include:
// 1) a type name, with no new constraint.
// 2) a type name, further constrained.
// 3) a resolution function, with a new type name.
subtype_indication > [ IIRScram_TypeDefinition *retval]:
  <<
    $retval = NULL;
    IIR                 *tolerance              = NULL;
    IIRScram_Name            *resolution_function    = NULL;
    IIRScram_TypeDefinition  *base_type              = NULL;
    IIRScram_TypeDefinition  *new_constrained_type   = NULL;
  >>
  // This half of the "|" handles subtypes with resolution functions.
  ((complex_name > [resolution_function] type_mark > [ base_type ])?
  complex_name > [resolution_function] type_mark > [ base_type ]
  {
    constraint[ base_type, resolution_function ] > [ new_constrained_type ]
    <<
      if( new_constrained_type != NULL ){
	new_constrained_type->set_type_mark( base_type );
      }
    >>
  }
  <<
    // If there wasn't a constraint, and there was a resolution
    // function, we need to build a new subtype.  (If there was a
    // constraint, then constraint took care of it all.)
    if( new_constrained_type == NULL && resolution_function != NULL ){
      $retval = base_type->_construct_new_subtype( resolution_function, NULL );
      $retval->set_type_mark( base_type );
    }
    else{
      ASSERT( new_constrained_type != NULL );
      $retval = new_constrained_type;
    }
  >>
  <<dynamic_cast<IIRScram_TypeDefinition *>($retval)->_type_check();>>
| // This half of the "|" handles subtypes without resolution functions.
  type_mark > [ base_type ]
  {
    constraint[ base_type, NULL ] > [ new_constrained_type ]
    <<
      if( new_constrained_type != NULL ){
        new_constrained_type->set_type_mark( base_type );
      }
    >>
  }
  <<
    if( new_constrained_type == NULL ){
      $retval = base_type;
    }
    else{
      $retval = new_constrained_type;
    }
  >>
  )
  <<>>
  { 
    (TOLERANCE)?
    <<lang_proc->processing_vhdl_ams()>>?
      [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
    TOLERANCE expression > [tolerance]
  }
  <<
    if( $retval != NULL ){
      dynamic_cast<IIRScram_TypeDefinition *>($retval)->_type_check();
    }
  >>
;

selected_or_simple_name > [ IIRScram_Name *retval ]:
  <<$retval = NULL;>>
  simple_name > [$retval]
  (
    <<IIRScram_Name *suffix = NULL;>>
    dot:DOT simple_name > [suffix]
    <<
      IIRScram_SelectedName *new_name = NULL;
      new_name = new IIRScram_SelectedName();
      new_name->set_prefix( $retval );
      new_name->set_suffix( suffix );
      copy_location( dot, new_name );
      $retval = new_name;
    >>
  )*
;

type_mark > [IIRScram_TypeDefinition *retval]:
  << 
    $retval = NULL;
    IIRScram_Name *type_name = NULL;
    IIRScram_Name *attribute = NULL;
  >>
  selected_or_simple_name > [type_name]
  { (QUOTE)?
    <<lang_proc->processing_vhdl_ams()>>?
      [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
    QUOTE ( attribute_across[attribute] > [attribute]
          | attribute_through[attribute] > [attribute] ) }
  <<
    constraint_functor *functor = new is_type_functor();
    savant::set<IIRScram_TypeDefinition*> *type_set = dynamic_cast<IIRScram_Name *>(type_name)->_get_rval_set(functor);
    delete functor;
    if( type_set == NULL ){
      report_undefined_symbol( type_name );
    }
    else if( type_set->size() > 1 ){
      report_ambiguous_error( type_name, type_set->convert_set<IIR_Declaration*>() );
      panic("type_mark resolution failed in VHDLParser::type_mark");
    }
    else{
      // Then type_set is non-NULL has one element in it.
      ASSERT( type_set->size() == 1 );
      $retval = *type_set->begin();
      ASSERT( $retval != NULL );
      if( $retval == NULL ){
        ostringstream err;
        err << "|" << *dynamic_cast<IIRScram_Name *>(type_name) << "| was not declared as a type in this scope";
        report_error( type_name, err.str() );
      }
//      copy_location(type_name, $retval);
      delete type_name;
    }
    delete type_set;
  >> 
;

constraint[ IIRScram_TypeDefinition *type_def, 
	    IIRScram_Name *resolution_function ] > [IIRScram_TypeDefinition *constrained_type ]: 
  <<
    $constrained_type = NULL;
    IIRScram_ScalarTypeDefinition *additional_constraint = NULL;
  >>
  range_constraint > [ additional_constraint ]
  <<
    ASSERT( type_def != NULL || parse_error == TRUE );
    if( type_def != NULL ){
      $constrained_type = 
	dynamic_cast<IIRScram_TypeDefinition *>(type_def)->_construct_new_subtype( dynamic_cast<IIRScram_Name *>(resolution_function), dynamic_cast<IIRScram_ScalarTypeDefinition *>(additional_constraint) );
    }
  >>
| index_constraint[ type_def ] > [$constrained_type]
  <<
    ASSERT( type_def != NULL || parse_error == TRUE );
  >>
;

index_constraint[ IIRScram_TypeDefinition *type_definition ] > [ IIRScram_TypeDefinition *constrained_type ]:
  << 
    IIRScram_TypeDefinition          *array_type                     = NULL;
    IIRScram_ScalarTypeDefinition    *current_constraint             = NULL;
    IIRScram_TypeDefinition          *final_constrained_type         = NULL;
    IIRScram_TypeDefinition          *previous_constrained_type      = NULL;
    IIRScram_TypeDefinition          *final_unconstrained_type       = NULL;
    IIRScram_TypeDefinition          *previous_unconstrained_type    = NULL;
  >>
  l_paren:L_PAREN 
  <<
    if( dynamic_cast<IIRScram_TypeDefinition *>(type_definition)->is_array_type() == TRUE ){
      array_type = type_definition;
    }
  >>
  discrete_range > [current_constraint] 
  <<
    if( array_type == NULL ){
      ostringstream err;
      err << "Index constraints may only be applied to array types.";
      report_error( current_constraint, err.str() );
    }
    else{
      if( dynamic_cast<IIRScram_TypeDefinition *>(array_type)->is_unconstrained_array_type() == FALSE ){
        ostringstream err;
        cerr << "Index constraints may only be applied to unconstrained array types.";
        report_error( array_type, err.str() );
      }
      if( current_constraint != NULL ){
	$constrained_type = dynamic_cast<IIRScram_TypeDefinition *>(array_type)->_index_constrain_array( dynamic_cast<IIRScram_ScalarTypeDefinition *>(current_constraint) );
	final_constrained_type = $constrained_type;
	final_unconstrained_type = array_type;
      }
    }
  >>
  ( 
    COMMA discrete_range > [current_constraint]
    <<
      if( array_type != NULL ){
        ASSERT( dynamic_cast<IIRScram_TypeDefinition *>(final_constrained_type)->is_array_type() == TRUE );
        ASSERT( dynamic_cast<IIRScram_TypeDefinition *>(final_unconstrained_type)->is_array_type() == TRUE );
        previous_constrained_type = final_constrained_type;
        previous_unconstrained_type = final_unconstrained_type;
  
        IIRScram_TypeDefinition *old_element_type = dynamic_cast<IIRScram_TypeDefinition *>(previous_unconstrained_type)->_get_element_subtype();
        if( dynamic_cast<IIRScram *>(old_element_type)->is_array_type() == FALSE ||
	    dynamic_cast<IIRScram_TypeDefinition *>(old_element_type)->is_anonymous() == FALSE ){
	  ostringstream err;
	  err << "Index constraints must be applied to array types.";
	  report_error( array_type, err.str() );
	  return $constrained_type;
	}
	IIRScram_TypeDefinition *new_constrained_type = NULL;
	new_constrained_type = dynamic_cast<IIRScram_TypeDefinition *>(old_element_type)->_index_constrain_array(dynamic_cast<IIRScram_ScalarTypeDefinition *>(current_constraint));
	dynamic_cast<IIRScram_TypeDefinition *>(previous_constrained_type)->set_element_subtype( dynamic_cast<IIRScram_TypeDefinition *>( new_constrained_type ) );
	final_constrained_type = new_constrained_type;
	final_unconstrained_type = dynamic_cast<IIRScram_TypeDefinition *>(previous_unconstrained_type)->_get_element_subtype();
      }
    >>
  )* 
  R_PAREN 
  <<
    if( array_type != NULL ){
      ASSERT( dynamic_cast<IIRScram *>(final_unconstrained_type)->is_array_type() == TRUE );
      dynamic_cast<IIRScram_TypeDefinition *>(final_constrained_type)->set_element_subtype( dynamic_cast<IIRScram_TypeDefinition *>(final_unconstrained_type)->_get_element_subtype() );
    }
  >>
;

constant_declaration[IIR_DeclarationList *list]:
<<
  IIRScram_ConstantDeclaration       *new_decl       = NULL;
  IIRScram_IdentifierList            *id_list        = NULL;
  IIRScram_Identifier                *id             = NULL;
  IIRScram_TypeDefinition            *type_def       = NULL;
  IIR                           *initial_value  = NULL;
>>
  constant:CONSTANT
  <<id_list = new IIRScram_IdentifierList();>>
  identifier_list[id_list] COLON subtype_indication > [type_def] {initialization > [initial_value]} SEMI_COLON
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      new_decl = new IIRScram_ConstantDeclaration();
      copy_location( id, new_decl );
      new_decl->set_declarator( id );
      if( initial_value != NULL ){
        new_decl->set_value(initial_value);
      }
      new_decl->set_subtype( type_def );

      dynamic_cast<IIRScram_ConstantDeclaration *>(new_decl)->_add_declaration( );
      $list->append( new_decl );
      dynamic_cast<IIRScram_ConstantDeclaration *>(new_decl)->_type_check();

      // need to remove instead of taking successor because current 
      // linked list class does not process duplicate members
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
    delete id_list;
  >>
;

identifier_list[IIR_IdentifierList *list]:
  <<IIRScram_Identifier *id = NULL;>>
  identifier > [id] <<$list->append(id);>>
  ( COMMA identifier > [id] <<$list->append(id);>> )*
;

initialization > [IIRScram *s]:
  <<$s = NULL;>>
  COLON_EQUAL expression > [$s]
;

signal_declaration[IIR_DeclarationList *list]:
  <<
    IIRScram_SignalDeclaration       *new_signal     = NULL;
    IIRScram_TypeDefinition          *subtype        = NULL;
    IIRScram_IdentifierList          *id_list        = NULL;
    IIR_SignalKind              sig_kind        = IIR_NO_SIGNAL_KIND;
    IIR                         *initial_value  = NULL;
    IIRScram_Identifier              *id             = NULL;
  >>
  signal:SIGNAL
  <<id_list = new IIRScram_IdentifierList();>>
  identifier_list[id_list] COLON
  subtype_indication > [subtype]
  { signal_kind > [sig_kind] }
  { initialization > [initial_value] }
  SEMI_COLON
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      new_signal = new IIRScram_SignalDeclaration();
      copy_location( id, new_signal );
      new_signal->set_declarator(id);
      new_signal->set_subtype( subtype );
      new_signal->set_signal_kind( sig_kind );
      new_signal->set_value(initial_value);
      dynamic_cast<IIRScram_SignalDeclaration *>(new_signal)->_type_check();

      dynamic_cast<IIRScram_SignalDeclaration *>(new_signal)->_add_declaration();
      $list->append(new_signal);

      // need to remove instead of taking successor because current 
      // linked list class does not process duplicate members
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
    delete id_list;
  >>
;

signal_kind > [IIR_SignalKind kind]:
  <<$kind = IIR_REGISTER_KIND;>>
  REGISTER <<$kind = IIR_REGISTER_KIND;>>
| BUS <<$kind = IIR_BUS_KIND;>>
;

shared_variable_declaration[IIR_DeclarationList *list]:
  SHARED VARIABLE variable_declaration_body[$list, TRUE]
;

variable_declaration[ IIR_DeclarationList *list ]:
  <<IIR_Boolean shared = FALSE;>>
  { SHARED <<shared = TRUE;>> } VARIABLE 
  variable_declaration_body[$list, shared]	
;

variable_declaration_body[IIR_DeclarationList *list, bool shared]:
  <<
    IIRScram_ObjectDeclaration       *new_decl       = NULL;
    IIRScram_IdentifierList          *id_list        = NULL;
    IIRScram_Identifier              *id             = NULL;
    IIR                         *initial_value  = NULL;
    IIRScram_TypeDefinition          *subtype        = NULL;
  >>
  <<id_list = new IIRScram_IdentifierList();>>
  identifier_list[id_list] COLON
  subtype_indication > [ subtype ]
  { initialization > [ initial_value ] } SEMI_COLON
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      if( shared == FALSE ){ 
        IIRScram_VariableDeclaration *new_var_decl =  new IIRScram_VariableDeclaration();
        new_var_decl->set_value(initial_value);
	copy_location( id, new_var_decl );
        new_decl = new_var_decl;
      }
      else {
        IIRScram_SharedVariableDeclaration *new_shared_decl = new IIRScram_SharedVariableDeclaration();
	copy_location( id, new_shared_decl );
        new_shared_decl->set_value( initial_value );
        new_decl = new_shared_decl;
      }

      new_decl->set_declarator( id );
      new_decl->set_subtype( subtype );
      dynamic_cast<IIRScram_ObjectDeclaration *>(new_decl)->_type_check();

      dynamic_cast<IIRScram_ObjectDeclaration *>(new_decl)->_add_declaration();
      $list->append(new_decl);

      // need to remove instead of taking successor because current 
      // linked list class does not process duplicate members
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
    delete id_list;
  >>
;

file_declaration[IIR_DeclarationList *list]:
  <<
    IIRScram_FileDeclaration         *new_file               = NULL;
    IIRScram_IdentifierList          *id_list                = NULL;
    IIRScram_TypeDefinition          *subtype                = NULL;
    IIRScram_Identifier              *id                     = NULL;
    IIRScram_DeclarationList         *file_decl_list         = NULL;
    IIR                         *open_information       = NULL;
    IIR                         *logical_name           = NULL;
  >>
  file_:FILE_
  <<id_list = new IIRScram_IdentifierList();>>
  identifier_list[id_list] COLON        
  subtype_indication > [subtype]
  { file_open_information > [open_information, logical_name] }
  SEMI_COLON
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      new_file = new IIRScram_FileDeclaration();
      new_file->set_declarator(id);
      new_file->set_subtype(subtype);
      new_file->set_file_open_expression( open_information );
      new_file->set_file_logical_name( logical_name );
      copy_location( id, new_file );
      dynamic_cast<IIRScram_FileDeclaration *>(new_file)->_add_declaration();
      $list->append(new_file); 
      // need to remove instead of taking successor because current 
      // linked list class does not process duplicate members
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
    delete id_list;
  >>
;

file_open_information > [IIRScram *open_information, IIRScram *logical_name]:
  <<
    $open_information = NULL;
    $logical_name = NULL;
    IIRScram *orig = NULL;
  >>
  { OPEN expression > [$open_information]
    <<
      orig = $open_information;
      $open_information =   dynamic_cast<IIRScram *>($open_information->_type_check_file_open_information());
      if( orig != $open_information ){
	delete orig;
      }
    >>

  }
  IS file_logical_name > [$logical_name]
;

mode > [IIR_Mode retval]:
  <<$retval = IIR_IN_MODE;>>
  IN <<$retval = IIR_IN_MODE;>>
| OUT <<$retval = IIR_OUT_MODE;>>
| INOUT <<$retval = IIR_INOUT_MODE;>>
| BUFFER <<$retval = IIR_BUFFER_MODE;>>
| LINKAGE <<$retval = IIR_LINKAGE_MODE;>>
;

file_logical_name > [IIRScram *retval]:
  <<$retval = NULL;>>
  expression > [$retval]
  <<
    if( $retval != 0 ){
      IIRScram_TypeDefinition *string_type = dynamic_cast<IIRScram_TypeDefinition *>(my_std_package->get_string_type());
      $retval = dynamic_cast<IIRScram *>($retval)->_semantic_transform( dynamic_cast<IIRScram_TypeDefinition *>(string_type) );
      dynamic_cast<IIRScram *>($retval)->_type_check( dynamic_cast<IIRScram_TypeDefinition *>(string_type) );
      $retval = dynamic_cast<IIRScram *>($retval)->_rval_to_decl( dynamic_cast<IIRScram_TypeDefinition *>(string_type) );
    }
  >>
;

interface_declaration[IIRScram_InterfaceDeclaration::_InterfaceListType ilt, IIR_List *list]:
  <<
    InterfaceListObjectType     obj_type        = ILOT_UNSPECIFIED;
    IIRScram_IdentifierList          *id_list        = new IIRScram_IdentifierList();
    IIR_Mode                    modde           = IIR_IN_MODE;
    IIRScram_TypeDefinition          *subtype_ind    = NULL;
    IIR_SignalKind              signal_kind     = IIR_NO_SIGNAL_KIND;
    IIR                         *initial_value  = NULL;
  >>
  ( { (
        CONSTANT <<obj_type = ILOT_CONSTANT;>> 
      | SIGNAL <<obj_type = ILOT_SIGNAL;>> 
      | VARIABLE <<obj_type = ILOT_VARIABLE;>>
      )
    }
    identifier_list[id_list] COLON { mode > [modde] } subtype_indication > [subtype_ind]
    { BUS <<signal_kind = IIR_BUS_KIND;>> }
    { initialization > [initial_value] }
  | FILE_ <<obj_type = ILOT_FILE;>>
    identifier_list[id_list] COLON
    subtype_indication > [subtype_ind]
  | <<lang_proc->processing_vhdl_ams()>>?
      [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
    ( TERMINAL <<obj_type = ILOT_TERMINAL;>>
      identifier_list[id_list] COLON 
      subnature_indication > [subtype_ind]
    | QUANTITY identifier_list[id_list] COLON 
             { IN <<modde = IIR_IN_MODE;>>| OUT <<modde = IIR_OUT_MODE;>> } 
             subtype_indication > [subtype_ind] {initialization > [initial_value]}
    )
  )
  <<
    switch ($ilt) {
    case IIR_InterfaceDeclaration::PORT_INTERFACE_LIST:
      if (obj_type == ILOT_UNSPECIFIED){
	obj_type = ILOT_SIGNAL;
      }
      if ((obj_type != ILOT_SIGNAL) && (obj_type != ILOT_TERMINAL)){
	report_error( "Interface declarations in port lists must be either of type signal or (in VHDL-AMS) terminal.\n",
		      LT(1)->getLine(),
		      my_design_file->get_name() );
	obj_type = ILOT_SIGNAL;
      }
      break;
    case IIR_InterfaceDeclaration::GENERIC_INTERFACE_LIST:
      if (obj_type == ILOT_UNSPECIFIED) {
	obj_type = ILOT_CONSTANT;
      }
      if (obj_type != ILOT_CONSTANT) {
	report_error( "Interface declarations in generic lists must be of type constant.", 
		      LT(1)->getLine(),
		      my_design_file->get_name());
	obj_type = ILOT_CONSTANT;
      }
      break;
    case IIR_InterfaceDeclaration::PARAMETER_INTERFACE_LIST:
      if ((modde != IIR_IN_MODE) && (modde != IIR_INOUT_MODE) && (modde != IIR_OUT_MODE)) {
	report_error("Parameter list interface declarations can only be in, inout, or out.",
		     LT(1)->getLine(),
		     my_design_file->get_name());
	modde = IIR_IN_MODE;
      }
      if (obj_type == ILOT_UNSPECIFIED) {
	if (modde == IIR_IN_MODE) {
	  obj_type = ILOT_CONSTANT;
	} else {
	  obj_type = ILOT_VARIABLE;
	}
      }
      break;
    }
    if ((signal_kind == IIR_BUS_KIND) && (obj_type != ILOT_SIGNAL)) {
      report_error("Only signal interface declarations can be defined as guarded (using the bus keyword).", 
		   LT(1)->getLine(),
		   my_design_file->get_name());
    }
    IIRScram_Identifier *id = NULL;
    for ( id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
	  id!=NULL;
	  id = dynamic_cast<IIRScram_Identifier *>(id_list->successor(id)) ){
      IIRScram_InterfaceDeclaration *new_decl = NULL;
      switch (obj_type){
      case ILOT_TERMINAL:{
	new_decl = new IIRScram_TerminalInterfaceDeclaration();
	modde = IIR_UNKNOWN_MODE;
	break;
      }
      case ILOT_FILE:{
	new_decl = new IIRScram_FileInterfaceDeclaration();
	break;
      }
      case ILOT_CONSTANT:{
	new_decl = new IIRScram_ConstantInterfaceDeclaration();
	break;
      }
      case ILOT_VARIABLE:{
	new_decl = new IIRScram_VariableInterfaceDeclaration();
	break;
      }
      case ILOT_SIGNAL:{
	IIRScram_SignalInterfaceDeclaration *sig_decl = new IIRScram_SignalInterfaceDeclaration();
	sig_decl->set_signal_kind(signal_kind);
	new_decl = sig_decl;
	break;
      }
      default:
	report_error( id, "Unknown object type in interface declaration." );
	abort();
	break;
      }
      copy_location( id, new_decl );
      new_decl->set_subtype(subtype_ind);
      new_decl->set_declarator(id);
      new_decl->set_mode(modde);
      new_decl->set_value(initial_value);
      dynamic_cast<IIRScram_InterfaceDeclaration *>(new_decl)->_type_check(ilt);
      $list->append(new_decl);
    }
    delete id_list;
  >>
;

interface_list[IIRScram_InterfaceDeclaration::_InterfaceListType ilt, IIR_List *list]:
  interface_declaration[$ilt, list]
  (SEMI_COLON interface_declaration[$ilt, list])*
;

association_list_in[IIR_AssociationList *alist]:
  <<IIRScram_AssociationElement *elem = NULL;>>
  association > [elem] <<$alist->append(elem);>>
  ( COMMA association > [elem] <<$alist->append(elem);>> )*
;

association > [IIRScram_AssociationElement *new_association]:
  <<
    $new_association                                    = NULL;
    IIRScram_AssociationElementByExpression  *by_expression  = NULL;
    IIRScram_AssociationElement              *actual         = NULL;
  >>
  association_element > [ $new_association ]
  { EQUAL_GREATER association_element > [ actual ] }
  <<
    if( $new_association->get_kind() == IIR_ASSOCIATION_ELEMENT_BY_EXPRESSION ){
      by_expression = dynamic_cast<IIRScram_AssociationElementByExpression *>($new_association);
      if (actual == NULL ){
        by_expression->set_actual( $new_association->get_formal() );
        by_expression->set_formal( NULL );
      }
      else {
        // Then the second association holds the actual part in its 
        // "get_formal" method.
        by_expression->set_actual( actual->get_formal() );
	ASSERT( actual->get_kind() == IIR_ASSOCIATION_ELEMENT_BY_EXPRESSION );
        delete actual;
      }
    }
  >>
;

association_element > [ IIRScram_AssociationElement *new_association ]:
  <<
    $new_association            = NULL;
    IIR                 *expr   = NULL;
  >>
  expression > [ expr ]
  <<
    $new_association = new IIRScram_AssociationElementByExpression();
    $new_association->set_formal( expr );
    copy_location( expr, $new_association );
  >>
| open:OPEN 
  <<
    $new_association = new IIRScram_AssociationElementOpen();
    $new_association->set_formal( NULL );
    copy_location(open, $new_association );
  >>
;

alias_declaration[IIR_DeclarationList *list]:
  <<
    IIRScram_AliasDeclaration        *new_decl                       = NULL;
    IIRScram_TextLiteral             *designator                     = NULL;
    IIRScram_DesignatorExplicit      *aliased_entity                 = NULL;
    IIRScram_Signature               *aliased_entity_signature       = NULL;
    IIRScram_TypeDefinition          *subtype                        = NULL;
    IIR                         *aliased_entity_name            = NULL;
  >>
  alias:ALIAS 
  <<
    new_decl = new IIRScram_AliasDeclaration();
    copy_location( alias,  new_decl );
  >>
  alias_designator > [designator] <<new_decl->set_declarator( designator );>>
  { COLON alias_indication > [subtype] <<new_decl->set_subtype( subtype );>> } 
  IS complex_name > [ aliased_entity_name ] <<new_decl->set_name( aliased_entity_name );>>
  { 
    signature > [ aliased_entity_signature ]
    <<
      aliased_entity = new IIRScram_DesignatorExplicit();
      aliased_entity->set_signature( aliased_entity_signature );
      aliased_entity->set_name( aliased_entity_name );
      new_decl->set_name( aliased_entity );
    >>
  }
  SEMI_COLON
  <<
    dynamic_cast<IIRScram_AliasDeclaration *>(new_decl)->_type_check();
    list->append( new_decl );
    dynamic_cast<IIRScram_AliasDeclaration *>(new_decl)->_add_declaration();
  >>
;


alias_designator > [IIRScram_TextLiteral *desig]:
  <<$desig = NULL;>>
  identifier > [$desig]
| char_lit:CHARACTER_LITERAL
  <<
    $desig = dynamic_cast<IIRScram_TextLiteral*>(mytoken(char_lit)->getIIRPtr());
    copy_location( char_lit, $desig );
  >>
| operator_symbol > [$desig]
;

alias_indication > [IIRScram_TypeDefinition *retval]:
  <<IIRScram_TypeDefinition *base_type = NULL;>>
  (type_mark >[base_type] TOLERANCE)?
  <<lang_proc->processing_vhdl_ams()>>?
    [lang_proc->report_not_vhdl_ams((ANTLRToken *)LT(1));]
  subnature_indication > [$retval]
| subtype_indication > [$retval]
;

component_declaration[IIR_DeclarationList *decl_list]:
  <<
    IIRScram_ComponentDeclaration    *new_component          = NULL;
    IIRScram_Identifier              *component_name       = NULL;
    IIRScram_Name                    *end_simple_name        = NULL;
  >>
  component:COMPONENT 
  <<
    new_component = new IIRScram_ComponentDeclaration();
    copy_location( component, new_component );
  >>
  identifier > [component_name]
  <<
    new_component->set_declarator(component_name);

  // lookup the default entity for this component in the library manager;
  // if you decide to change this approach to using the symbol table, a
  // good example of doing that is show in the actions for the goto_label
  // in the grammar rule for "next_statement"
  int num_found = 0;
  savant::set<IIR_LibraryDeclaration*> *libraries = library_manager::instance()->get_libraries();
  IIR_EntityDeclaration *entity = NULL;
  ostringstream err;

  for (auto lib = libraries->begin();
       lib != libraries->end();
       lib++) {
    ASSERT( *lib != NULL );
    entity = library_manager::instance()->lookup_entity(FALSE, 
							component_name, 
							*lib, 
							my_std_package, 
							my_factory);
    // we found a matching entity
    if (entity != NULL) {
      new_component->set_entity(entity);
      num_found++;
    }
  }
  switch (num_found) {
  case 0: {
    // we didn't find it; we will assume that it is made visible by a configuration
    break;
  }
  case 1: {
    // we found it
    break;
  }
  default: {
    // we found multiple matching names; we will not make a binding and assume a configuration will identify the specific entity
    new_component->set_entity(NULL);
    break;
  }
  }

    dynamic_cast<IIRScram_ComponentDeclaration *>(new_component)->_add_declaration_and_open_scope();
  >>
  { IS }
  { generic_clause[new_component->get_local_generic_clause()] }
  { port_clause[new_component->get_local_port_clause()] }
  END COMPONENT 
  {
    simple_name > [end_simple_name]
    <<check_name( component_name, end_simple_name, "component" );>>
  } 
  SEMI_COLON
  <<
    decl_list->append( new_component );
    my_symbol_table->close_scope( new_component );
  >>
;

generic_clause[ IIR_GenericList *list ]:
  generic:GENERIC <<copy_location( generic, $list );>>
  L_PAREN generic_list[$list] R_PAREN SEMI_COLON
;

port_clause[IIR_PortList *list]:
  port:PORT <<copy_location( port, list );>>
  L_PAREN port_list[list] R_PAREN SEMI_COLON
;

generic_list[IIR_GenericList *list]:
  interface_list[IIRScram_InterfaceDeclaration::GENERIC_INTERFACE_LIST, list]
  <<my_symbol_table->add_declaration( list );>>
;

port_list[IIR_PortList *list]:
  interface_list[IIRScram_InterfaceDeclaration::PORT_INTERFACE_LIST,list]
  <<my_symbol_table->add_declaration( list );>>
;

group_declaration[ IIR_DeclarationList *list ]:
  <<
    IIRScram_Identifier              *group_name             = NULL;
    IIRScram_Name                    *group_template_name    = NULL;
    IIRScram_GroupDeclaration        *new_group_decl         = new IIRScram_GroupDeclaration();
  >>
  keyword:GROUP identifier > [group_name] COLON selected_or_simple_name > [ group_template_name ]
  <<
    if( dynamic_cast<IIRScram_GroupDeclaration *>(group_template_name)->is_name() != TRUE ){
      // There is  no general purpose method for printing names yet.
      report_error("No group template by name [Internal error] found");
    }
    new_group_decl->set_group_template( group_template_name );
  >>
  L_PAREN 
  group_constituent_list[ new_group_decl->get_group_constituent_list() ]
  R_PAREN
  SEMI_COLON
  <<
    dynamic_cast<IIRScram_GroupDeclaration *>(new_group_decl)->_add_declaration();
    list->append( new_group_decl );
  >>
;

group_template_declaration[ IIR_DeclarationList *list ]:
  <<
    IIRScram_Identifier                      *group_name                     = NULL;
    IIRScram_GroupTemplateDeclaration        *new_group_template_decl        = new IIRScram_GroupTemplateDeclaration();
  >>
  keyword:GROUP identifier > [group_name] IS 
  L_PAREN 
  entity_class_entry_list[ new_group_template_decl->get_entity_class_entry_list() ]
  R_PAREN
  <<
    dynamic_cast<IIRScram_GroupTemplateDeclaration *>(new_group_template_decl)->_add_declaration();
    list->append( new_group_template_decl );
  >>
;

entity_class_entry_list[IIR_EntityClassEntryList *list]:
  <<IIRScram_EntityClassEntry *ent_class_entry = NULL;>>
  entity_class_entry > [ ent_class_entry ] <<$list->append( ent_class_entry );>>
  (
    COMMA entity_class_entry > [ ent_class_entry ] 
    <<$list->append( ent_class_entry );>>
  )*
;

entity_class_entry > [ IIRScram_EntityClassEntry *new_entity_class_entry ]:
  <<
    $new_entity_class_entry = NULL;
    IIRScram_Identifier *not_used = NULL;
    IIR_Kind ent_class;
    constraint_functor *functor = NULL;
  >>
  <<$new_entity_class_entry = new IIRScram_EntityClassEntry();>>
  entity_class > [not_used, ent_class, functor] 
  <<$new_entity_class_entry->set_entity_kind( ent_class );>>
  {
    box:LESS_GREATER 
    <<$new_entity_class_entry->set_boxed( TRUE );>>
  }
;

group_constituent_list[ IIR_DesignatorList *list ]:
  <<IIRScram_GroupConstituent *current_constituent = NULL;>>
  <<list = new IIRScram_DesignatorList();>>
  group_constituent > [ current_constituent ]
  <<
    IIRScram_DesignatorExplicit *list_element = new IIRScram_DesignatorExplicit();
    copy_location( current_constituent, list_element );
    list_element->set_name( current_constituent );
    list->append( list_element );
  >>
  (
    COMMA group_constituent > [ current_constituent ]
    <<
      IIRScram_DesignatorExplicit *list_element = new IIRScram_DesignatorExplicit();
      copy_location( current_constituent, list_element );
      list_element->set_name( current_constituent );
      list->append( list_element );
    >>
  )*
;

group_constituent > [IIRScram_GroupConstituent *retval]:
  <<IIRScram *name = NULL;>>
  (CHARACTER_LITERAL)? char_lit:CHARACTER_LITERAL
  <<
    IIRScram_Literal *lit = dynamic_cast<IIRScram_Literal *>(mytoken(char_lit)->getIIRPtr());
    copy_location( char_lit, lit );
    $retval = new IIRScram_GroupConstituent();
    $retval->set_name( lit );
    copy_location( char_lit, $retval );
  >>
| complex_name > [ name ]
  <<
    $retval = new IIRScram_GroupConstituent();
    $retval->set_name( name );
  >>
;

/* **********************************************************************

expressions

********************************************************************** */

boolean_expression > [IIRScram *expr]:
  <<
    $expr = NULL;
  >>
  expression > [$expr] 
;

time_expression > [IIRScram *expr]:
  <<
    $expr = NULL;
  >>
  expression > [$expr] 
;

expression > [IIRScram *e]:
  <<
    $e = NULL;
    IIRScram *wk = NULL;
  >>
  relation > [$e] expression_tail[$e] > [wk] <<if (wk!=NULL) {$e = wk;}>>
;

expression_tail[IIRScram *p] > [IIRScram *e]:
  <<
    IIRScram_DyadicOperator  *be = NULL;
    IIR                 *wk = NULL;
    $e = $p;
  >>
  ( (AND_OR_XOR_XNOR)? logic1_op:AND_OR_XOR_XNOR relation > [wk]
    <<
      switch (logic1_op->getType()) {
      case AND: 
	be = new IIRScram_AndOperator();
	break;
      case OR: 
	be = new IIRScram_OrOperator();
	break;
      case XOR:
	be = new IIRScram_XorOperator();
	break;
      case XNOR:
	be = new IIRScram_XnorOperator();
	break;
      default: 
	//	    panic("rule \"expression_tail\" ");
	break;
      }
      copy_location( logic1_op, be );
      be->set_left_operand($e);
      be->set_right_operand(wk);
      $e = be;
    >>
  )+
| { (NAND_NOR)? logic2_op:NAND_NOR relation > [wk]
    <<
      switch (logic2_op->getType()) {
      case NAND: 
	be = new IIRScram_NandOperator();
	break;
      case NOR: 
	be = new IIRScram_NorOperator();
	break;
      default: 
	//		report_error(add_op, "Internal Compiler Error");
	break;
      }
      copy_location( logic2_op, be );
      be->set_left_operand($e);
      be->set_right_operand(wk);
      $e = be;
    >>
  }
;

relation > [IIRScram *e]:
  <<
    $e = NULL;
    IIRScram_DyadicOperator  *be = NULL;
    IIR                 *wk = NULL;
  >>
  shift_expression > [$e]
  { (RELATIONAL_OPERATOR)? rel_op:RELATIONAL_OPERATOR shift_expression > [wk]
    <<
      switch (rel_op->getType()) {
      case EQUAL: 
	be = new IIRScram_EqualityOperator();
	break;
      case NOT_EQUAL: 
	be = new IIRScram_InequalityOperator();
	break;
      case LESS:
	be = new IIRScram_LessThanOperator();
	break;
      case LESS_EQUAL:
	be = new IIRScram_LessThanOrEqualOperator();
	break;
      case GREATER:
	be = new IIRScram_GreaterThanOperator();
	break;
      case GREATER_EQUAL:
	be = new IIRScram_GreaterThanOrEqualOperator();
	break;
      default: 
	//		report_error(add_op, "Internal Compiler Error");
	break;
      }
      copy_location( rel_op, be );
      be->set_left_operand($e);
      be->set_right_operand(wk);
      $e = be;
    >>
  }
;

shift_expression > [IIRScram *e]:
  <<
    $e = NULL;
    IIRScram_DyadicOperator  *be = NULL;
    IIR                 *wk = NULL;
  >>
  simple_expression > [$e]
  { (SHIFT_OPERATOR)? shift_op:SHIFT_OPERATOR simple_expression > [wk]
    <<
      switch (shift_op->getType()) {
      case SLL: 
	be = new IIRScram_SLLOperator();
	break;
      case SLA: 
	be = new IIRScram_SLAOperator();
	break;
      case SRL: 
	be = new IIRScram_SRLOperator();
	break;
      case SRA: 
	be = new IIRScram_SRAOperator();
	break;
      case ROL: 
	be = new IIRScram_ROLOperator();
	break;
      case ROR: 
	be = new IIRScram_ROROperator();
	break;
      default: 
	//	        report_error(add_op, "Internal Compiler Error");
	break;
      }
      copy_location( shift_op, be );
      be->set_left_operand($e);
      be->set_right_operand(wk);
      $e = be;
    >>
  }
;

simple_expression > [IIRScram *e]:
  <<
    $e = NULL;
    IIRScram_DyadicOperator  *be             = NULL;
    IIRScram_MonadicOperator *ue             = NULL;
    IIR_Boolean         sign_op_present = FALSE;
    IIR                 *wk             = NULL;
  >>
  { sign_op:SIGN_OPERATOR <<sign_op_present = TRUE;>> } term > [$e]
  <<
    if( sign_op_present == TRUE ){
      switch (sign_op->getType()) {
      case PLUS: 
        ue = new IIRScram_IdentityOperator();
        break;
      case MINUS: 
        ue = new IIRScram_NegationOperator();
        break;
      default: 
	ASSERT( 0 );
      break;
      }
      copy_location( sign_op, ue );
      ue->set_operand($e);
      $e = ue;
    }
  >>
  ( (ADDING_OPERATOR)? add_op:ADDING_OPERATOR term > [wk]
    <<
      switch (add_op->getType()) {
      case PLUS: 
	be = new IIRScram_AdditionOperator();
	break;
      case MINUS: 
	be = new IIRScram_SubtractionOperator();
	break;
      case AMPERSAND:
	be = new IIRScram_ConcatenationOperator();
	break;
      default: 
	ASSERT( 0 );
	break;
      }
      copy_location( add_op, be );
      be->set_left_operand($e);
      be->set_right_operand(wk);
      $e = be;
    >>
  )*
;

term > [IIRScram *e]:
  <<
    $e = NULL;
    IIR                 *wk = NULL;
    IIRScram_DyadicOperator  *be = NULL;
  >>
  factor > [$e]
  ( (MULTIPLYING_OPERATOR)? mult_op:MULTIPLYING_OPERATOR factor > [wk]
    <<
      switch (mult_op->getType()) {
      case MULTIPLY: 
	be = new IIRScram_MultiplicationOperator();
	break;
      case DIVIDE: 
	be = new IIRScram_DivisionOperator();
	break;
      case MOD: 
	be = new IIRScram_ModulusOperator();
	break;
      case REM: 
	be = new IIRScram_RemainderOperator();
	break;
      default: 
	//		report_error(add_op, "Internal Compiler Error");
	break;
      }
      copy_location( mult_op, be );
      be->set_left_operand($e);
      be->set_right_operand(wk);
      $e = be;
    >>
  )*
;

factor > [IIRScram *e]:
  <<
    $e = NULL;
    IIR                 *wk = NULL;
    IIRScram_DyadicOperator  *be = NULL;
    IIRScram_MonadicOperator *ue = NULL;
  >>
  primary > [$e] 
  { 
    (exp:EXPONENT primary > [wk])?
    <<
      be = new IIRScram_ExponentiationOperator();
      copy_location( exp, be );
      be->set_left_operand($e);
      be->set_right_operand(wk);
      $e = be;
    >>
  }
| abs_not:ABS_NOT primary > [wk]
  <<
    switch (abs_not->getType()) {
    case ABS: 
    ue = new IIRScram_AbsoluteOperator();
    break;
    case NOT:
    ue = new IIRScram_NotOperator();
    break;
    default: 
    break;
    }
    copy_location( abs_not, ue );
      ue->set_operand(wk);      
      $e = ue;
  >>
;

numeric_literal > [ IIRScram *retval ]:
  <<
    $retval = NULL;
    IIRScram_Literal         *lit            = NULL;
    IIRScram_Name            *unit_name      = NULL;
  >>
  abstract_literal > [lit] <<$retval = lit;>>
  { (IDENTIFIER)? complex_name > [unit_name]
    <<  
      savant::set<IIRScram_Declaration*> *decl_set = dynamic_cast<IIRScram_Name *>(unit_name)->_symbol_lookup();
      if( decl_set == NULL ){
	report_undefined_symbol( unit_name );
      }
      IIRScram_Declaration *decl = resolve_if_one( decl_set,
						   dynamic_cast<IIRScram_Name *>(unit_name) );
      if( decl != NULL ){
	if( decl->get_kind() != IIR_PHYSICAL_UNIT ){
	  ostringstream err;
	  err << *dynamic_cast<IIRScram_Name *>(unit_name) << " has not been declared as a physical unit in"
	      << " this scope.";
	  report_error( unit_name, err.str() );
	}
	else{
	  IIRScram_PhysicalUnit      *pu             = dynamic_cast<IIRScram_PhysicalUnit *>(decl);
	  IIRScram_PhysicalLiteral   *phys_lit       = new IIRScram_PhysicalLiteral();
	  copy_location( unit_name, phys_lit );
	  phys_lit->set_abstract_literal( lit ); 
	  phys_lit->set_unit_name( pu );
	  $retval = phys_lit;
	}
      }
      else{
	panic("Resolution failed in numeric literal");
      }
    >>
  }
;

literal > [ IIRScram *retval ]:
  <<
    $retval = NULL;
    IIRScram_EnumerationLiteral *eliteral = NULL;
  >>
  numeric_literal > [ $retval ]
| char_lit:CHARACTER_LITERAL
  <<
    eliteral = new IIRScram_EnumerationLiteral();
    copy_location( char_lit, eliteral );
    eliteral->set_declarator( dynamic_cast<IIRScram_TextLiteral*>(mytoken(char_lit)->getIIRPtr()) );          
    $retval = eliteral;
  >>
| string_lit:STRING_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_StringLiteral*>(mytoken(string_lit)->getIIRPtr());
    copy_location( string_lit, $retval );
  >>
| bit_string_lit:BIT_STRING_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_BitStringLiteral*>(mytoken(bit_string_lit)->getIIRPtr());
    copy_location( bit_string_lit, $retval );
  >>	       
| null_lit:NULL_
  << 
    $retval = dynamic_cast<IIRScram *>(IIRScram_StringLiteral::get( "null", 4, my_factory)); 
    copy_location( null_lit, $retval );
  >>
;

primary > [IIRScram *retval]:
  <<
    $retval = NULL;
    IIRScram_Aggregate *new_aggregate = NULL;
  >>
  (STRING_LITERAL L_PAREN)? complex_name > [$retval]
| (literal > [$retval])?
| complex_name > [$retval]
| allocator > [$retval]
| aggregate > [ new_aggregate ] <<$retval = reduce_aggregate( dynamic_cast<IIRScram_Aggregate *>(new_aggregate) );>> 
;

association_list_out > [IIR_AssociationList *list]:
  <<
    $list = NULL;
    IIRScram_AssociationElement *expr = NULL;
  >>
  element_association > [expr] 
  <<
    $list = new IIRScram_AssociationList();
    $list->append(expr);
  >>
  (
    COMMA element_association > [expr] 
    <<$list->append(expr);>>
  )*
;

allocator > [IIRScram_Allocator *alloc]:
  <<
    $alloc                                      = NULL;
    IIRScram_TypeDefinition  *type                   = NULL;
    IIRScram_Name            *qualified_expression   = NULL;
  >>
  ( 
    new_:NEW subtype_indication > [type]
    <<
      $alloc = new IIRScram_Allocator();
      copy_location( new_, $alloc );
      $alloc->set_type_mark(type);
    >>
  )?
|
  // This should pick up a qualified_expression
  (
    new__:NEW complex_name > [ qualified_expression ]
    <<
      if( qualified_expression->get_kind() == IIR_USER_ATTRIBUTE ){
	$alloc = new IIRScram_Allocator();
	copy_location( new__, $alloc );
	IIRScram_UserAttribute *as_attr = dynamic_cast<IIRScram_UserAttribute *>(qualified_expression);
	
        savant::set<IIRScram_TypeDefinition*> *allocator_types = dynamic_cast<IIRScram_Name *>(qualified_expression)->_get_rval_set();
	if( allocator_types == NULL ){
	  report_undefined_symbol( qualified_expression );
	}
	
	switch( allocator_types->size() ){
	case 0:{
	  // This shouldn't be possible.
	  ASSERT(0);
	  break;
	}
	case 1:{
	  IIRScram_TypeDefinition *allocator_type = *allocator_types->begin();
     ASSERT( allocator_type != NULL );
	  $alloc->set_type_mark( allocator_type );
	  
	  IIRScram *initializer = dynamic_cast<IIRScram *>(as_attr->get_suffix());
	  if( initializer != NULL ){
	    initializer = initializer->_semantic_transform( allocator_type );
	    initializer->_type_check( allocator_type );
	    initializer = initializer->_rval_to_decl( allocator_type );
	  }
	  
	  $alloc->set_value( initializer );
	  
	  break;
	}
	default:{
	  report_ambiguous_error( qualified_expression, allocator_types->convert_set<IIR_TypeDefinition*>() );
	  break;
	}
	}
      }
    else{
      ostringstream err;
      err << "Allocators apply to subtypes, and qualifed expressions. |" << *dynamic_cast<IIRScram_Name *>(qualified_expression)
	  << "| is neither.";
      report_error( qualified_expression, err.str() );
    }
    >>
  )
;

element_association > [IIRScram_AssociationElement *assoc]:
  <<
    $assoc = NULL;
    IIRScram *expr = NULL;
    IIRScram_CaseStatementAlternative *alt = NULL;
  >>
  (choices > [alt] line_info:EQUAL_GREATER expression > [expr])? 
  <<
    switch( alt->get_kind() ){
    case IIR_CASE_STATEMENT_ALTERNATIVE_BY_OTHERS:{
      IIRScram_AssociationElementByExpression *by_expr = new IIRScram_AssociationElementByExpression();
      by_expr->set_actual( expr );
      IIRScram_OthersInitialization *others = new IIRScram_OthersInitialization();
      others->set_expression( expr );
      by_expr->set_formal( others );
      delete alt;
      $assoc = by_expr;
      break;
    }
    case IIR_CASE_STATEMENT_ALTERNATIVE_BY_EXPRESSION:{
      IIRScram_AssociationElementByExpression *by_expr = new IIRScram_AssociationElementByExpression();
      IIRScram_CaseStatementAlternativeByExpression *case_by_expression = 
	dynamic_cast<IIRScram_CaseStatementAlternativeByExpression *>(alt);
      
      by_expr->set_actual( expr );
      by_expr->set_formal( case_by_expression->get_choice()->get_value() );
      
      delete case_by_expression;
      
      $assoc = by_expr;
      break;
    }
    default:{
      panic("Default case reached in VHDLParser::element_association");
    }
    }
    copy_location( line_info, $assoc );
  >>
| association > [$assoc]
;

/* **********************************************************************

 names

********************************************************************** */

complex_name > [IIRScram_Name *name]:
  <<$name = NULL;>>
  attribute_name > [$name]
;

attribute_name > [IIRScram_Name *name]:
  <<$name = NULL;>>
  selected_name > [$name] ( QUOTE attribute[$name] > [$name] )*
;

attribute[IIRScram_Name *prefix] > [IIRScram_Name *retval]:
  <<
    $retval = NULL;
    IIRScram *wk = NULL;
    IIRScram_Aggregate *initializer = NULL;
  >>
  (selected_name > [wk])? attribute_user_defined[prefix] > [$retval]
  /* The following rule is ams specific, but since it's first symbol is the
     ABOVE token, <it will not be expanded unless the ABOVE
     token is recognized by the lexer.  Since the lexer won't generate this
     token without the AMS switch, I have not prefixed this rule the test
     for VHDL-AMS.  paw */
| attribute_above[prefix] > [$retval] 
| attribute_active[prefix] > [$retval]
| attribute_ascending[prefix] > [$retval]
| attribute_base[prefix] > [$retval]
  /* The following rule is ams specific, but since it's first symbol is the
     CONTRIBUTION token, it will not be expanded unless the CONTRIBUTION
     token is recognized by the lexer.  Since the lexer won't generate this
     token without the AMS switch, I have not prefixed this rule the test
     for VHDL-AMS.  paw */
| attribute_contribution[prefix] > [$retval]
| attribute_delayed[prefix] > [$retval]
  /* The following rule is ams specific, but since it's first symbol is the
     DOT token, it will not be expanded unless the DOT token is recognized
     by the lexer.  Since the lexer won't generate this token without the
     AMS switch, I have not prefixed this rule the test for VHDL-AMS.  paw */
| attribute_dot[prefix] > [$retval]
| attribute_driving_value[prefix] > [$retval]
| attribute_driving[prefix] > [$retval]
| attribute_event[prefix] > [$retval]
| attribute_high[prefix] > [$retval]
| attribute_image[prefix] > [$retval]
| attribute_instance_name[prefix] > [$retval]
| attribute_last_active[prefix] > [$retval]
| attribute_last_event[prefix] > [$retval]
| attribute_last_value[prefix] > [$retval]
| attribute_leftof[prefix] > [$retval]
| attribute_left[prefix] > [$retval]
| attribute_length[prefix] > [$retval]
| attribute_low[prefix] > [$retval]
  /* The following rule is ams specific, but since it's first symbol is the
     LTF token, it will not be expanded unless the LTF token is recognized
     by the lexer.  Since the lexer won't generate this token without the
     AMS switch, I have not prefixed this rule the test for VHDL-AMS.  paw */
| attribute_ltf[prefix] > [$retval]
| attribute_path_name[prefix] > [$retval]
| attribute_pos[prefix] > [$retval]
| attribute_pred[prefix] > [$retval]
| attribute_range[prefix] > [$retval]
  /* The following rule is ams specific, but since it's first symbol is the
     REFERENCE token, it will not be expanded unless the REFERENCE token is
     recognized by the lexer.  Since the lexer won't generate this token
     without the AMS switch, I have not prefixed this rule the test for
     VHDL-AMS.  paw */
| attribute_reference[prefix] > [$retval]
| attribute_rightof[prefix] > [$retval]
| attribute_right[prefix] > [$retval]
| attribute_reverse_range[prefix] > [$retval]
| attribute_simple_name[prefix] > [$retval]
| attribute_stable[prefix] > [$retval]
| attribute_succ[prefix] > [$retval]
| attribute_transaction[prefix] > [$retval]
| attribute_quiet[prefix] > [$retval]
| attribute_value[prefix] > [$retval]
| attribute_val[prefix] > [$retval]
  /* The following rule is ams specific, but since it's first symbol is the
     ZTF token, it will not be expanded unless the ZTF token is recognized
     by the lexer.  Since the lexer won't generate this token without the
     AMS switch, I have not prefixed this rule the test for VHDL-AMS.  paw */
| attribute_ztf[prefix] > [$retval]
| (aggregate > [initializer])  
  <<
    IIRScram_UserAttribute *new_attr = new IIRScram_UserAttribute();
    copy_location( prefix, new_attr );
    new_attr->set_prefix( prefix );
    new_attr->set_suffix( reduce_aggregate( dynamic_cast<IIRScram_Aggregate *>(initializer) ) );
    $retval = new_attr;
  >> 
;

attribute_user_defined[IIRScram *p] > [IIRScram_UserAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  selected_name > [wk]
  <<
    $s = new IIRScram_UserAttribute();
    copy_location( wk, $s );
    $s->set_prefix(p);
    $s->set_suffix(wk);
  >>
;

attribute_above[IIRScram *p] > [IIRScram_AboveAttribute *s]:
  <<$s = NULL;>>
  start:ABOVE
  <<
    $s = new IIRScram_AboveAttribute();
    copy_location (start,$s);
    $s->set_prefix(p);
  >>
;

attribute_across[IIRScram *p] > [IIRScram_AcrossAttribute *s]:
  <<$s = NULL;>>
  start:ACROSS
  <<
    $s = new IIRScram_AcrossAttribute();
    copy_location (start,$s);
    $s->set_prefix(p);
  >>
;

attribute_active[IIRScram *p] > [IIRScram_ActiveAttribute *s]: 
  <<$s = NULL;>>
  start:ACTIVE
  <<
    $s = new IIRScram_ActiveAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_ascending[IIRScram *prefix] > [IIRScram_AscendingAttribute *attr]:
  <<
    $attr = NULL;
    IIRScram *expr = NULL;
  >>
  start:ASCENDING 
  <<
    $attr = new IIRScram_AscendingAttribute();
    copy_location( start, $attr );
    $attr->set_prefix(prefix);
  >>
  { (L_PAREN)? L_PAREN expression > [expr] R_PAREN <<$attr->set_suffix(expr);>> }
;

attribute_base[IIRScram *p] > [IIRScram_BaseAttribute *s]: 
  <<$s = NULL;>>
  start:BASE 
  <<
    $s = new IIRScram_BaseAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_contribution[IIRScram *p] > [IIRScram_ContributionAttribute *s]:
  <<$s = NULL;>>
  start:CONTRIBUTION
  <<
    $s = new IIRScram_ContributionAttribute();
    copy_location (start,$s);
    $s->set_prefix(p);
  >>
;

attribute_delayed[IIRScram *p] > [IIRScram_DelayedAttribute *s]: 
  << 
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:DELAYED 
  <<
    $s = new IIRScram_DelayedAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_dot[IIRScram *p] > [IIRScram_DotAttribute *s]:
  <<
   $s = NULL;
   IIRScram *wk = NULL;
 >>
 start:DOT_
 <<
   $s = new IIRScram_DotAttribute();
   copy_location(start,$s);
   $s->set_prefix(p);
  >>
;

attribute_driving_value[IIRScram *p] > [IIRScram_DrivingValueAttribute *s]: 
  <<$s = NULL;>>
  start:DRIVING_VALUE 
  <<
    $s = new IIRScram_DrivingValueAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_driving[IIRScram *p] > [IIRScram_DrivingAttribute *s]: 
  <<$s = NULL;>>
  start:DRIVING 
  <<
    $s = new IIRScram_DrivingAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_event[IIRScram *p] > [IIRScram_EventAttribute *s]: 
  <<$s = NULL;>>
  start:EVENT 
  <<
    $s = new IIRScram_EventAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_high[IIRScram *p] > [IIRScram_HighAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:HIGH 
  <<
    $s = new IIRScram_HighAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_image[IIRScram *p] > [IIRScram_ImageAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:IMAGE 
  <<
    $s = new IIRScram_ImageAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>>
;

attribute_instance_name[IIRScram *p] > [IIRScram_InstanceNameAttribute *s]: 
  <<$s = NULL;>>
  start:INSTANCE_NAME 
  <<
    $s = new IIRScram_InstanceNameAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_last_active[IIRScram *p] > [IIRScram_LastActiveAttribute *s]: 
  <<$s = NULL;>>
start:LAST_ACTIVE 
  <<
    $s = new IIRScram_LastActiveAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_last_event[IIRScram *p] > [IIRScram_LastEventAttribute *s]: 
  <<$s = NULL;>>
  start:LAST_EVENT 
  <<
    $s = new IIRScram_LastEventAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_last_value[IIRScram *p] > [IIRScram_LastValueAttribute *s]: 
  <<$s = NULL;>>
  start:LAST_VALUE 
  <<
    $s = new IIRScram_LastValueAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_leftof[IIRScram *p] > [IIRScram_LeftOfAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:LEFTOF 
  <<
    $s = new IIRScram_LeftOfAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>>
;

attribute_left[IIRScram *p] > [IIRScram_LeftAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:LEFT 
  <<
    $s = new IIRScram_LeftAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_length[IIRScram *p] > [IIRScram_LengthAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:LENGTH 
  <<
    $s = new IIRScram_LengthAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_low[IIRScram *p] > [IIRScram_LowAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:LOW 
  <<
    $s = new IIRScram_LowAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_ltf[IIRScram *p] > [IIRScram_LTFAttribute *s]:
  <<
    $s = NULL;
    IIRScram *numer;
    IIRScram *denom;
  >>
  start:LTF
  <<
    $s = new IIRScram_LTFAttribute();
    copy_location( start,$s);
    $s->set_prefix(p);
  >>
  L_PAREN expression > [numer] COMMA
  expression > [denom] R_PAREN
  << 
    $s->set_num(numer);
    $s->set_den(denom);
  >>    
;
attribute_path_name[IIRScram *p] > [IIRScram_PathNameAttribute *s]: 
  <<$s = NULL;>>
  start:PATH_NAME 
  <<
    $s = new IIRScram_PathNameAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_pos[IIRScram *p] > [IIRScram_PosAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:POS 
  <<
    $s = new IIRScram_PosAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>>
;

attribute_pred[IIRScram *p] > [IIRScram_PredAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:PRED 
  <<
    $s = new IIRScram_PredAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>>
;

attribute_range[IIRScram *p] > [IIRScram_RangeAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:RANGE
  <<
    $s = new IIRScram_RangeAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_reference[IIRScram *p] > [IIRScram_ReferenceAttribute *s]:
  <<$s = NULL;>>
  start:REFERENCE
  <<
    $s = new IIRScram_ReferenceAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_rightof[IIRScram *p] > [IIRScram_RightOfAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:RIGHTOF 
  <<
    $s = new IIRScram_RightOfAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>>
;

attribute_right[IIRScram *p] > [IIRScram_RightAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:RIGHT 
  <<
    $s = new IIRScram_RightAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_reverse_range[IIRScram *p] > [IIRScram_ReverseRangeAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:REVERSE_RANGE
  <<
    $s = new IIRScram_ReverseRangeAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_simple_name[IIRScram *p] > [IIRScram_SimpleNameAttribute *s]: 
  <<$s = NULL;>>
  start:SIMPLE_NAME 
  <<
    $s = new IIRScram_SimpleNameAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_stable[IIRScram *p] > [IIRScram_StableAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:STABLE 
  <<
    $s = new IIRScram_StableAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_succ[IIRScram *p] > [IIRScram_SuccAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:SUCC 
  <<
    $s = new IIRScram_SuccAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>>
;

attribute_through[IIRScram *p] > [IIRScram_ThroughAttribute *s]:
  <<$s = NULL;>>
  start:THROUGH
  <<
    $s = new IIRScram_ThroughAttribute();
    copy_location( start,$s);
    $s->set_prefix(p);
  >>
;

attribute_transaction[IIRScram *p] > [IIRScram_TransactionAttribute *s]: 
  <<$s = NULL;>>
  start:TRANSACTION 
  <<
    $s = new IIRScram_TransactionAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
;

attribute_quiet[IIRScram *p] > [IIRScram_QuietAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:QUIET 
  <<
    $s = new IIRScram_QuietAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_value[IIRScram *p] > [IIRScram_ValueAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:VALUE 
  <<
    $s = new IIRScram_ValueAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  { (L_PAREN)? L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>> }
;

attribute_val[IIRScram *p] > [IIRScram_ValAttribute *s]: 
  <<
    $s = NULL;
    IIRScram *wk = NULL;
  >>
  start:VAL 
  <<
    $s = new IIRScram_ValAttribute();
    copy_location( start, $s );
    $s->set_prefix(p);
  >>
  L_PAREN expression > [wk] R_PAREN <<$s->set_suffix(wk);>>
;

attribute_ztf[IIRScram *p] > [IIRScram_ZTFAttribute *s]:
    <<
        $s = NULL;
        IIRScram *numer;
        IIRScram *denom;
        IIRScram *s_period;
        IIRScram *delay;
    >>
        start:ZTF
    <<
        $s = new IIRScram_ZTFAttribute();
        copy_location( start,$s);
        $s->set_prefix(p);
    >>
    L_PAREN
    expression > [numer] COMMA
    expression > [denom] COMMA
    expression > [s_period] COMMA
    expression > [delay]
    R_PAREN
    <<
    $s->set_num(numer);
    $s->set_den(denom);
    $s->set_t(s_period);
    $s->set_initial_delay(delay);
  >>
;

selected_name > [IIRScram_Name *name]:
  <<
    $name = NULL;
    IIRScram_SelectedName    *selected_name  = NULL;
    IIRScram_IndexedName     *ind_name       = NULL;
    IIR                 *index_spec     = NULL;
    IIR                 *by_all         = NULL;
  >>
  indexed_name[NULL] > [$name]
  ( dot:DOT
    (
      <<>>
      <<
        selected_name = new IIRScram_SelectedName();
        copy_location( dot, selected_name);
        selected_name->set_prefix( $name );
        $name = selected_name;
      >>
      indexed_name[$name] > [$name]
    |
      all:ALL
      <<
        selected_name = new IIRScram_SelectedName();
        copy_location( dot, selected_name );
        selected_name->set_prefix( $name );
        by_all = new IIRScram_DesignatorByAll();
        copy_location( all, by_all );
        selected_name->set_suffix( by_all );
        $name = selected_name;
      >>
      ( 
        paren:L_PAREN index_specifier > [index_spec] 
        <<
          ind_name = new IIRScram_IndexedName();
          copy_location( paren, ind_name );
          ind_name->set_prefix( $name );
          ind_name->set_suffix(index_spec);
          $name = ind_name;
        >>
        R_PAREN
      )*
    )
  )*
;

indexed_name[IIRScram_Name *prefix] > [IIRScram_Name *retval]:
  <<
    $retval                             = NULL;
    IIR                 *index_spec     = NULL;
    IIRScram_IndexedName     *ind_name       = NULL;
  >>
  name > [$retval]
  <<
    if ($prefix != NULL) {
      dynamic_cast<IIRScram_Name *>($prefix)->_set_suffix(dynamic_cast<IIRScram *>($retval));
      $retval = $prefix;
    };
  >>
  (
    paren:L_PAREN
    index_specifier > [index_spec]
    <<
      ind_name = new IIRScram_IndexedName();
      copy_location( paren, ind_name );
      ind_name->set_prefix( $retval );
      ind_name->set_suffix(dynamic_cast<IIRScram *>(index_spec));
      $retval = ind_name;
    >>
    R_PAREN
  )*
;

index_specifier > [IIRScram *retval]:
  <<
    $retval                                     = NULL;
    IIR                         *expr, *dir     = NULL;
    IIR_AssociationList         *list           = NULL;
    IIRScram_ScalarTypeDefinition    *temp_range     = NULL;
    IIRScram_ScalarTypeDefinition    *scalar_type    = NULL;
  >>
  (expression > [expr] direction > [dir])?
  discrete_range > [ temp_range ] 
  <<
    if( temp_range != NULL && temp_range->get_kind() == IIR_RANGE_TYPE_DEFINITION ){
      IIRScram_RangeTypeDefinition *temp = dynamic_cast<IIRScram_RangeTypeDefinition *>(temp_range);
      scalar_type = IIRScram_ScalarTypeDefinition::_determine_discrete_type(dynamic_cast<IIRScram_RangeTypeDefinition *>(temp));
      $retval = dynamic_cast<IIRScram_ScalarTypeDefinition *>(scalar_type)->_construct_new_subtype( NULL, dynamic_cast<IIRScram_RangeTypeDefinition *>( temp ) );
      delete temp;
    }
    else{
      $retval = temp_range;
    }
  >>
  { EQUAL_GREATER expression > [expr] }
| association_list_out > [list] <<$retval = reduce_association_list( dynamic_cast<IIRScram_AssociationList *>(list) );>>
;

name > [IIRScram_Name *retval]:
  <<
    $retval = NULL;
    IIRScram_StringLiteral           *string_literal = NULL;
    IIRScram_CharacterLiteral        *character_literal = NULL;
  >>
  simple_name > [$retval]
| string_lit:STRING_LITERAL
  <<
    string_literal = dynamic_cast<IIRScram_StringLiteral*>(mytoken(string_lit)->getIIRPtr());
    dynamic_cast<IIRScram_StringLiteral *>(string_literal)->_to_lower();
    copy_location( string_lit, string_literal );
    $retval = new IIRScram_SimpleName();
    $retval->set_prefix(string_literal);
    copy_location( string_lit, $retval );
  >>
| character_lit:CHARACTER_LITERAL
  <<
    character_literal = dynamic_cast<IIRScram_CharacterLiteral*>(mytoken(character_lit)->getIIRPtr());
    copy_location( character_lit, character_literal );
    $retval = new IIRScram_SimpleName();
    $retval->set_prefix(character_literal);
    copy_location( character_lit, $retval );
  >>
;

simple_name > [IIRScram_SimpleName *retval]:
  <<
    $retval = NULL;
    IIRScram_Identifier *id = NULL;
  >>
  identifier > [ id ]
  <<
    $retval = new IIRScram_SimpleName();
    $retval->set_prefix( id );
    copy_location( id, $retval );
  >>
;

alpha_literals > [IIRScram_Literal *retval]:
  <<$retval = NULL;>>
  bit_string_lit:BIT_STRING_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_BitStringLiteral*>(mytoken(bit_string_lit)->getIIRPtr());
    copy_location( bit_string_lit, $retval);
  >>
| char_lit:CHARACTER_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_Literal*>(mytoken(char_lit)->getIIRPtr());
    copy_location( char_lit,  $retval );
  >>
| string_lit:STRING_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_StringLiteral*>(mytoken(string_lit)->getIIRPtr());
    copy_location( string_lit, $retval );
  >>
| null_lit:NULL_ 
  <<
    $retval =
       dynamic_cast<IIRScram_Literal *>(IIRScram_StringLiteral::get( "null", 4, my_factory ));
    copy_location( null_lit, $retval );
  >>
;

physical_type_name > [ IIRScram_Identifier *name ]:
  <<$name = NULL;>>
  identifier > [$name]
;

discrete_range > [IIRScram_ScalarTypeDefinition *retval ]:
  <<
    $retval = NULL;
    IIRScram_TypeDefinition *base_type = NULL;
  >>
  ( range > [ $retval ] )?
| subtype_indication > [ base_type ]
  <<
    if( base_type != NULL ){
      if( dynamic_cast<IIRScram_TypeDefinition *>(base_type)->is_discrete_type() == FALSE ){
	ostringstream err;
	err << "|" << *dynamic_cast<IIRScram_TypeDefinition *>(base_type) << "| is not a discrete type.";
	report_error( base_type, err.str() );
      }
      else{
	ASSERT( dynamic_cast<IIRScram_TypeDefinition *>(base_type)->is_scalar_type() == TRUE );
	$retval = dynamic_cast<IIRScram_ScalarTypeDefinition *>(base_type);
      }
    }
  >>
;

direction > [IIRScram_EnumerationLiteral *s]:
  <<$s = NULL;>> 
  // This has return a pointer to the enumeration defined in package standard 
  // corresponding to true or false.  True = to, False = downto
  to_:TO 
  <<
    $s = dynamic_cast<IIRScram_EnumerationLiteral *>(my_std_package->get_true_literal());
    copy_location( to_, $s );    
  >>
| downto_:DOWNTO  
  <<
    $s = dynamic_cast<IIRScram_EnumerationLiteral *>(my_std_package->get_false_literal());
    copy_location( downto_, $s );
  >>
;

vhdl_label > [IIRScram_Label *new_label]:
  <<
    $new_label = NULL;
    IIRScram_Identifier *id = NULL;
  >>
  identifier > [id]
  <<
    $new_label = new IIRScram_Label();
    $new_label->set_declarator(id);
    copy_location( id, $new_label );
  >>
;


integer_literal > [IIRScram_IntegerLiteral *retval]:
  <<$retval = NULL;>>
  integer_lit:DECIMAL_INTEGER_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_IntegerLiteral*>(mytoken(integer_lit)->getIIRPtr());
    copy_location( integer_lit, $retval );
  >>
| based_lit:BASED_INTEGER_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_IntegerLiteral*>(mytoken(based_lit)->getIIRPtr());
    copy_location( based_lit, $retval );
  >>
;

real_literal > [IIRScram_FloatingPointLiteral *retval]:
  <<$retval = NULL;>>
  real_lit:DECIMAL_FLOATING_POINT_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_FloatingPointLiteral*>(mytoken(real_lit)->getIIRPtr());
    copy_location( real_lit, $retval );
  >>
| based_lit:BASED_FLOATING_POINT_LITERAL
  <<
    $retval = dynamic_cast<IIRScram_FloatingPointLiteral*>(mytoken(based_lit)->getIIRPtr());
    copy_location( based_lit, $retval );
  >>
;

identifier > [IIRScram_Identifier *ident]:
  <<$ident = NULL;>>
  id:IDENTIFIER
  <<
    $ident = dynamic_cast<IIRScram_Identifier*>(mytoken(id)->getIIRPtr());
    string temp_text = $ident->convert_to_string();
    copy_location( id, $ident );
  >>
;


/* **********************************************************************

Grammar Rules for VHDL-AMS

********************************************************************** */

nature_declaration[IIR_DeclarationList *decl_list]:
  <<
    IIRScram_Identifier              *nature_id      = NULL;
    IIRScram_NatureDeclaration       *nature_decl    = NULL;
    IIRScram_NatureDefinition        *nature_def     = NULL;
  >>
  nature:NATURE identifier > [nature_id] IS
  <<
    nature_decl = new IIRScram_NatureDeclaration();
    copy_location(nature, nature_decl);
  >>
  nature_definition[nature_decl] > [nature_def] SEMI_COLON
  << 
    nature_def->set_declaration(nature_decl);
    nature_decl->set_declarator(nature_id);
    nature_decl->set_nature(nature_def);
    dynamic_cast<IIRScram_NatureDeclaration *>(nature_decl)->_add_declaration();
    dynamic_cast<IIRScram_NatureDeclaration *>(nature_decl)->_type_check();
    $decl_list->append(nature_decl); 
    if( (nature_def->get_kind() != IIR_ARRAY_SUBNATURE_DEFINITION) && (nature_def->get_kind() != IIR_ARRAY_NATURE_DEFINITION) )
    $decl_list->append(dynamic_cast<IIRScram_NatureDeclaration *>(nature_decl)->get_reference_terminal());
  >>
;

nature_definition[IIRScram_NatureDeclaration *nature_decl] > [IIRScram_NatureDefinition *nature_def]:
  scalar_nature_definition[nature_decl] > [$nature_def]
| array_nature_definition[nature_decl] > [$nature_def]
| record_nature_definition
;

terminal_declaration[IIR_DeclarationList *decl_list]:
  <<
    IIRScram_IdentifierList          *id_list        = NULL;
    IIRScram_TerminalDeclaration     *new_decl       = NULL;
    IIRScram_NatureDefinition        *nature_def     = NULL;
    IIRScram_Identifier              *id             = NULL;
  >>
  terminal:TERMINAL 
  <<id_list = new IIRScram_IdentifierList();>>
  identifier_list[id_list] COLON
  subnature_indication > [nature_def]
  SEMI_COLON   
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      new_decl = new IIRScram_TerminalDeclaration();
      new_decl->set_declarator(id);
      new_decl->set_nature(nature_def);   
      new_decl->set_subtype(nature_def);
      dynamic_cast<IIRScram_TerminalDeclaration *>(new_decl)->_type_check();
      copy_location( id,new_decl);
      dynamic_cast<IIRScram_TerminalDeclaration *>(new_decl)->_add_declaration();
      $decl_list->append( new_decl );
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
    delete id_list;
  >>
;

quantity_declaration[IIR_DeclarationList *decl_list]:
  quantity:QUANTITY quantity_declaration_tail[$decl_list]
;

quantity_declaration_tail[IIR_DeclarationList *decl_list]:
  <<
    IIRScram_IdentifierList  *id_list        = new IIRScram_IdentifierList();
    IIRScram_TypeDefinition  *type_def       = NULL;
    IIRScram                 *initial_value  = NULL;
    IIRScram                 *magnitude      = NULL;
    IIRScram                 *phase          = NULL;
    IIRScram                 *noise          = NULL;
  >>
  (identifier_list [id_list] COLON subtype_indication > [type_def]
  { initialization > [initial_value] }
  SEMI_COLON)? free_quantity_declaration[$decl_list]
  <<delete id_list;>>
| (identifier_list [id_list] COLON subtype_indication > [type_def]
  { source_aspect > [magnitude, phase, noise] }
  SEMI_COLON)? source_quantity_declaration[$decl_list]
| branch_quantity_declaration[$decl_list]
;

free_quantity_declaration [IIR_DeclarationList *decl_list]:
  <<
    IIRScram_FreeQuantityDeclaration         *new_decl = NULL;
    IIRScram_IdentifierList                  *id_list = new IIRScram_IdentifierList();
    IIRScram_Identifier                      *id = NULL;
    IIRScram_TypeDefinition                  *type_def = NULL;
    IIRScram                                 *initial_value = NULL;
  >>
  identifier_list [id_list] COLON subtype_indication > [type_def]
  { initialization > [initial_value] } SEMI_COLON
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      new_decl = new IIRScram_FreeQuantityDeclaration();
      copy_location( id, new_decl );
      new_decl->set_declarator( id );
      new_decl->set_value( initial_value );
      new_decl->set_subtype( type_def );
      dynamic_cast<IIRScram_FreeQuantityDeclaration *>(new_decl)->_add_declaration();
      dynamic_cast<IIRScram_FreeQuantityDeclaration *>(new_decl)->_type_check();
      $decl_list->append(new_decl);
      id_list->remove( id );
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
  >>
;

branch_quantity_declaration[IIR_DeclarationList *decl_list]:
  <<
    IIRScram                                         *across                 = NULL;
    IIRScram                                         *through                = NULL;
    IIRScram                                         *quan_name              = NULL;
    IIRScram                                         *plus_terminal          = NULL;
    IIRScram                                         *minus_terminal         = NULL;
    IIRScram                                         *across_value           = NULL;
    IIRScram                                         *across_tolerance       = NULL;
    IIRScram                                         *through_tolerance      = NULL;
    IIRScram                                         *nature_decl            = NULL;
    IIRScram_Designator                              *designator             = NULL;
    IIRScram_Declaration                             *terminal_plus_decl     = NULL;
    IIRScram_Declaration                             *terminal_minus_decl    = NULL;
    IIRScram_BranchQuantityDeclaration               *new_decl               = new IIRScram_BranchQuantityDeclaration();
    IIRScram_BranchQuantityDeclaration               *new_quan               = NULL;
    savant::set<IIRScram_Declaration*>                *plus_terminal_decl_set;
    savant::set<IIRScram_Declaration*>                *minus_terminal_decl_set;
    savant::set<IIR>                            *nature_decl_set;
    IIRScram_IdentifierList                          *id_list                = NULL;
  >>
  {
    ( identifier_list [id_list] {tolerance_aspect > [across_tolerance]} {initialization > [across_value] } ACROSS) ?
      across_aspect[new_decl->get_across_aspect_identifier_list()] >  [across_tolerance,across]
      <<
        new_decl->set_across_aspect_expression(across);
        new_decl->set_across_aspect_tolerance(across_tolerance);
      >>
  }
  {
    through_aspect[new_decl->get_through_aspect_designator_list()] > [through_tolerance,through]
    <<
      new_decl->set_through_aspect_expression(through);
      new_decl->set_through_aspect_tolerance(through_tolerance);
    >>
  }
  terminal_aspect > [plus_terminal,minus_terminal] SEMI_COLON
  <<
    if(plus_terminal){
      plus_terminal_decl_set = NULL;
      plus_terminal_decl_set = plus_terminal->_symbol_lookup();
    }
    if (plus_terminal_decl_set == NULL) {
      report_undefined_symbol(plus_terminal);
    }
    else {
      ASSERT( plus_terminal_decl_set->size() == 1 );
      terminal_plus_decl = *plus_terminal_decl_set->begin();
      ASSERT( terminal_plus_decl  != NULL );
      new_decl->set_plus_terminal_name(plus_terminal);
    }
    if (minus_terminal == NULL){
      IIRScram_Declaration           *plus_terminal_decl     = *plus_terminal_decl_set->begin();
      ASSERT( plus_terminal_decl  != NULL );
      IIRScram_TypeDefinition        *terminal_nature        = dynamic_cast<IIRScram_TypeDefinition *>(plus_terminal_decl)->_get_subtype();
      IIRScram_Declaration           *nature_decl            = dynamic_cast<IIRScram_Declaration *>(terminal_nature->get_declaration());

      terminal_minus_decl = dynamic_cast<IIRScram_Declaration*>(dynamic_cast<IIRScram_NatureDeclaration *>(nature_decl)->get_reference_terminal());
      new_decl->set_minus_terminal_name(terminal_minus_decl);
    }
    else {
       minus_terminal_decl_set = dynamic_cast<IIRScram *>(minus_terminal)->_symbol_lookup();
       ASSERT( minus_terminal_decl_set->size() == 1 );
       terminal_minus_decl      = *minus_terminal_decl_set->begin();
       ASSERT( terminal_minus_decl != NULL );
       new_decl->set_minus_terminal_name(terminal_minus_decl);
    }
    designator = dynamic_cast<IIRScram_Designator *>(new_decl->get_across_aspect_identifier_list()->first());
    while (designator != NULL) {
      quan_name = dynamic_cast<IIRScram *>(dynamic_cast<IIR_DesignatorExplicit *>(designator)->get_name());
      new_quan = new IIRScram_BranchQuantityDeclaration();
      copy_location( quan_name, new_quan );
      new_quan->set_declarator(dynamic_cast<IIRScram_TextLiteral *>(quan_name));
      new_quan->set_across_aspect_expression(across);
      new_quan->set_plus_terminal_name(terminal_plus_decl);
      new_quan->set_minus_terminal_name(terminal_minus_decl);
      new_quan->set_across_aspect_tolerance(across_tolerance);

      IIRScram_TypeDefinition        *nature_definition              = dynamic_cast<IIRScram_Declaration *>(terminal_plus_decl)->_get_subtype();
      IIRScram_TypeDefinition        *minus_nature_definition        = dynamic_cast<IIRScram_Declaration *>(terminal_minus_decl)->_get_subtype();
      IIRScram_TypeDefinition        *typedefn                       = NULL;

      typedefn = nature_definition->get_across();
      new_quan->set_subtype(typedefn);
      new_quan->get_across_aspect_identifier_list()->append(designator);
      dynamic_cast<IIRScram_BranchQuantityDeclaration *>(new_quan)->_add_declaration();
      $decl_list->append(new_quan);
      designator = dynamic_cast<IIRScram_Designator *>(new_decl->get_across_aspect_identifier_list()->successor(designator));
      dynamic_cast<IIRScram_BranchQuantityDeclaration *>(new_quan)->_type_check();
    }
  >>
  <<
    designator = dynamic_cast<IIRScram_Designator *>(new_decl->get_through_aspect_designator_list()->first());
    while (designator != NULL) {
      quan_name = dynamic_cast<IIRScram *>(dynamic_cast<IIRScram_DesignatorExplicit *>(designator)->get_name());
      new_quan = new IIRScram_BranchQuantityDeclaration();
      copy_location( quan_name, new_quan );
      new_quan->set_declarator( dynamic_cast<IIR_TextLiteral *>(quan_name) );
      new_quan->set_through_aspect_expression(through);
      new_quan->set_plus_terminal_name(terminal_plus_decl);
      new_quan->set_minus_terminal_name(terminal_minus_decl);
      new_quan->set_through_aspect_tolerance(through_tolerance);

      IIRScram_TypeDefinition        *nature_definition              = dynamic_cast<IIRScram_Declaration *>(terminal_plus_decl)->_get_subtype();
      IIRScram_TypeDefinition        *minus_nature_definition        = dynamic_cast<IIRScram_Declaration *>(terminal_minus_decl)->_get_subtype();
      IIRScram_TypeDefinition        *typedefn                       = NULL;

      new_quan->set_subtype(typedefn);
      new_quan->get_through_aspect_designator_list()->append(designator);
      dynamic_cast<IIRScram_BranchQuantityDeclaration *>(new_quan)->_add_declaration();
      $decl_list->append(new_quan);
      designator = dynamic_cast<IIRScram_Designator *>(new_decl->get_through_aspect_designator_list()->successor(designator));
      dynamic_cast<IIRScram_BranchQuantityDeclaration *>(new_quan)->_type_check();
    }
    delete new_decl;
  >>
;

source_quantity_declaration [IIR_DeclarationList *list]:   
  <<
    IIRScram_SourceQuantityDeclaration               *new_decl       = NULL;
    IIRScram_IdentifierList                          *id_list        = new IIRScram_IdentifierList();
    IIRScram_TypeDefinition                          *type_def       = NULL;
    IIRScram                                         *mag_exp        = NULL;  
    IIRScram                                         *ph_exp         = NULL;
    IIRScram                                         *noise_exp      = NULL;
    IIRScram_Identifier                              *id             = NULL;
    savant::set<IIRScram_Declaration*>                *mag_exp_set    = NULL;
    savant::set<IIRScram_Declaration*>                *ph_exp_set     = NULL;
    savant::set<IIRScram_Declaration*>                *noise_exp_set  = NULL;
  >>
  identifier_list [id_list] COLON subtype_indication > [type_def]
  source_aspect > [mag_exp, ph_exp, noise_exp] SEMI_COLON
  <<
    if (noise_exp==NULL) {
      if (mag_exp) {
        mag_exp_set = dynamic_cast<IIRScram *>(mag_exp)->_symbol_lookup();
      }
      if (mag_exp_set == 0) {
        report_undefined_symbol(mag_exp);
      }
      if( ph_exp ){
        ph_exp_set = ph_exp->_symbol_lookup();
      }
      if (ph_exp_set->size() == 0) {
        report_undefined_symbol(ph_exp);
      }
    } 
      else {
      if (noise_exp) {
        noise_exp_set = noise_exp->_symbol_lookup();
      }
      if (noise_exp_set->size() == 0) {
        report_undefined_symbol(noise_exp);
      }
    }
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while (id != NULL) {
      new_decl = new IIRScram_SourceQuantityDeclaration();
      copy_location( id, new_decl );
      new_decl->set_declarator(id);
      new_decl->set_magnitude_expression(mag_exp);
      new_decl->set_phase_expression(ph_exp);
      new_decl->set_noise_expression(noise_exp);
      new_decl->set_subtype(type_def);
      my_symbol_table->add_declaration( new_decl );
      $list->append(new_decl);
      id_list->remove(id);  
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }    		
  >>
;

across_aspect[IIR_DesignatorList *across_list ] > [IIRScram *across_tolerance, IIRScram *across_value]:
  <<
    $across_tolerance = NULL;
    IIRScram_IdentifierList *id_list = new IIRScram_IdentifierList();
    IIRScram_Identifier *id = NULL;;
    $across_value = NULL;
  >>
  identifier_list[id_list]
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while( id != NULL){
      IIRScram_DesignatorExplicit *designator = new IIRScram_DesignatorExplicit();
      designator->set_name(id);
      $across_list->append(designator);
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
  >>
  { tolerance_aspect > [$across_tolerance] }
  { initialization > [$across_value] } 
  across_:ACROSS
;

through_aspect[IIR_DesignatorList *through_list ] > [IIRScram *through_tolerance, IIRScram *through_value]:
  <<
    $through_tolerance                  = NULL;
    IIRScram_IdentifierList  *id_list        = new IIRScram_IdentifierList();
    IIRScram_Identifier      *id             = NULL;
    IIR                 *initial_value  = NULL;
    $through_value                      = NULL;
  >>
  identifier_list[id_list]
  <<
    id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    while( id != NULL ) {
      IIRScram_DesignatorExplicit *designator = new IIRScram_DesignatorExplicit();
      designator->set_name(id);
      $through_list->append(designator);
      id_list->remove(id);
      id = dynamic_cast<IIRScram_Identifier *>(id_list->first());
    }
  >>
  { tolerance_aspect > [$through_tolerance] }
  { initialization > [$through_value] }
  through_:THROUGH
;

terminal_aspect > [IIRScram *plus_terminal, IIRScram *minus_terminal]:
  <<$minus_terminal = NULL;>>
  simple_name > [ $plus_terminal ] { TO simple_name > [ $minus_terminal ] }
;

tolerance_aspect > [IIRScram *tolerance]:
  <<$tolerance = NULL;>>
  TOLERANCE expression > [$tolerance] 
  <<
    ostringstream err;
    err << "Tolerances in branch quantity declarations are not yet supported. "
        << "Using default tolerances. ";
    report_error( $tolerance, err.str(), WARNING );
  >>
;

source_aspect > [ IIRScram *magnitude_expr, IIRScram *phase_expr , IIRScram *noise_expr]:
  <<
    $magnitude_expr = NULL;
    $phase_expr = NULL;
    $noise_expr = NULL;
  >>
  NOISE simple_expression > [$noise_expr]
| SPECTRUM simple_expression > [$magnitude_expr] COMMA simple_expression > [$phase_expr]
;

step_limit_specification[IIR_DeclarationList *decl_list]:
  <<
    IIRScram_Name            *type_name      = NULL;
    IIRScram_TypeDefinition  *type_def       = NULL;
    IIR                 *expr           = NULL;
  >>
  LIMIT
  (
     selected_or_simple_name > [type_name] 
    ( COMMA selected_or_simple_name > [type_name] )*
  | OTHERS
  | ALL
  )
  COLON type_mark > [type_def] WITH expression > [expr] SEMI_COLON
;

scalar_nature_definition[IIRScram_NatureDeclaration *nature_decl] > [IIRScram_ScalarNatureDefinition *scalar_def]:
  <<
    $scalar_def                                         = NULL;
    IIRScram_TypeDefinition  *across_type_def                = NULL;
    IIRScram_TypeDefinition  *through_type_def               = NULL;
    IIRScram_Identifier      *reference_terminal_name        = NULL;
    IIR                 *across_tolerance               = NULL;
    IIR                 *through_tolerance              = NULL;
  >>   
  type_mark > [across_type_def] ACROSS
  <<
    $scalar_def = new IIRScram_ScalarNatureDefinition();
    $scalar_def->set_across(across_type_def);
  >> 
  type_mark > [through_type_def] THROUGH 
  <<
    $scalar_def->set_through(through_type_def);

  >>
  identifier > [reference_terminal_name] REFERENCE
  <<
    IIRScram_TerminalDeclaration *reference_terminal = NULL;
    reference_terminal = new IIRScram_TerminalDeclaration();
    reference_terminal->set_declarator(reference_terminal_name);
    $scalar_def->set_reference_terminal(reference_terminal);
  >>	
;

array_nature_definition[IIRScram_NatureDeclaration *nature_decl] > [IIRScram_ArrayNatureDefinition *array_def]:
  <<
    $array_def                                          = NULL;
    IIRScram_ScalarTypeDefinition    *index_subtype          = NULL;
    IIRScram_NatureDefinition        *element_subtype        = NULL;
    IIRScram_ArrayNatureDefinition   *prev_subtype           = NULL;
    IIRScram_ArrayNatureDefinition   *final_subtype          = NULL;
    IIR_Boolean                 is_unconstrained        = false;
    IIR_Boolean                 err_flag                = false;
  >>
  array_:ARRAY L_PAREN  array_dimension > [index_subtype]
  <<
    $array_def = IIRScram_ArrayNatureDefinition::_construct_array_type( dynamic_cast<IIRScram_ScalarTypeDefinition *>(index_subtype), NULL, dynamic_cast<IIRScram_NatureDeclaration *>(nature_decl) );
    if( dynamic_cast<IIRScram_ArrayNatureDefinition *>($array_def)->is_unconstrained_array_type() ){
     
      is_unconstrained = TRUE;
    }
    copy_location(array_, $array_def);
    final_subtype = $array_def;
  >>
  (COMMA array_dimension > [index_subtype]
    <<
      prev_subtype = final_subtype;
      final_subtype = IIRScram_ArraySubnatureDefinition::_construct_array_type( dynamic_cast<IIRScram_ScalarTypeDefinition *>(index_subtype), NULL, NULL );
      dynamic_cast<IIRScram_ArrayNatureDefinition *>(prev_subtype)->set_element_subtype( dynamic_cast<IIRScram_ArrayNatureDefinition *>(final_subtype) );
      ASSERT( dynamic_cast<IIRScram_ArrayNatureDefinition *>(prev_subtype)->_get_base_type() != NULL );
      ASSERT( dynamic_cast<IIRScram_ArrayNatureDefinition *>(prev_subtype)->_get_base_type()->_is_iir_array_type_definition() == TRUE );
      dynamic_cast<IIRScram_ArrayTypeDefinition *>((prev_subtype->get_base_type()))->set_element_subtype( dynamic_cast<IIRScram_ArrayNatureDefinition *>(final_subtype) );
      if( is_unconstrained == TRUE ){
      if( dynamic_cast<IIRScram_ArrayNatureDefinition *>(final_subtype)->is_unconstrained_array_type() == FALSE ){
	  err_flag = TRUE;
	}
      }
      else{
	if( dynamic_cast<IIRScram_ArrayNatureDefinition *>(final_subtype)->is_unconstrained_array_type() == TRUE ){
	  err_flag = TRUE;	
	}
      }

      if( err_flag == TRUE ){
	ostringstream err;
	err << "All indexes of an array must be either constrained or unconstrained."
	    << " They cannot be mixed.";
	report_error( index_subtype, err.str() );
      }
    >>
  )*
  R_PAREN OF subnature_indication > [element_subtype]
  <<
    if( dynamic_cast<IIRScram_NatureDefinition *>( element_subtype )->is_array_type() == TRUE ){
      dynamic_cast<IIRScram_NatureDefinition *>(element_subtype)->set_is_element( TRUE );
    }
    final_subtype->set_element_subtype(element_subtype);
    if( dynamic_cast<IIRScram_ArrayNatureDefinition *>(final_subtype)->get_base_type() != NULL ){
      ASSERT( dynamic_cast<IIRScram_ArrayNatureDefinition *>(final_subtype->get_base_type())->_is_iir_array_type_definition() == TRUE );
    (dynamic_cast<IIRScram_ArrayNatureDefinition *>(final_subtype->get_base_type()))->set_element_subtype( element_subtype );
    }
  >>
;

record_nature_definition:
  <<IIRScram_Name *end_name = NULL;>>
  record:RECORD
    ( nature_element_declaration )+
  END RECORD { simple_name > [end_name] }
;

nature_element_declaration:
  <<
    IIRScram_IdentifierList *id_list = NULL;
    IIRScram_TypeDefinition *elem_subtype = NULL;
  >>
  <<id_list = new IIRScram_IdentifierList();>>
  identifier_list[id_list] colon:COLON subnature_indication > [elem_subtype] SEMI_COLON
;

subnature_declaration[IIR_DeclarationList *list]:
  <<
    IIRScram_TypeDefinition  *type_definition        = NULL;
    IIRScram_Identifier      *subnature_name         = NULL;
  >>
  subnature:SUBNATURE identifier > [subnature_name] IS subnature_indication > [type_definition] SEMI_COLON
;

subnature_indication > [IIRScram_NatureDefinition *retval]:
  <<
    $retval                                             = NULL;
    IIRScram_NatureDefinition        *base_type              = NULL;
    IIRScram_TypeDefinition          *new_constrained_type   = NULL;
    IIR                         *tolerance_expression   = NULL;
    IIR                         *across_expression      = NULL;
  >>
  nature_mark > [base_type]
  {
    index_constraint[base_type] > [new_constrained_type]
    <<
      if( new_constrained_type != NULL ){
        new_constrained_type->set_type_mark( base_type );
      }
    >>
  }
  <<
    if( new_constrained_type == NULL){
      $retval = base_type;
    }
    else{
      $retval = dynamic_cast<IIRScram_NatureDefinition *>(new_constrained_type);
    }
  >>
  {  
    TOLERANCE expression > [tolerance_expression]
    ACROSS expression > [across_expression] THROUGH
  }
  <<
    if ($retval != NULL){
      dynamic_cast<IIRScram_NatureDefinition *>($retval)->_type_check();
    }
  >>  
;

nature_mark > [ IIRScram_NatureDefinition *retval ]:
  <<
    $retval = NULL;
    IIRScram_Name *nature_name = NULL;
  >>   
  selected_or_simple_name > [nature_name]
  <<
    savant::set<IIRScram_TypeDefinition*> *nature_set = nature_name->_get_rval_set();
    if( nature_set == NULL )  {
      report_undefined_symbol(nature_name);
    }
    else if( nature_set->size() > 1 ){
      report_ambiguous_error(nature_name, nature_set->convert_set<IIR_TypeDefinition*>());
      panic("nature_mark resolution failed in VHDLParser::nature_mark");
    }
    else {
      ASSERT( nature_set->size() == 1 );
      $retval = dynamic_cast<IIRScram_NatureDefinition *>(*nature_set->begin());
      if( $retval == NULL ){
        ostringstream err;
        err << "|" << *dynamic_cast<IIRScram_Name *>(nature_name) << "| was not declared as a nature in this scope";
        report_error( nature_name, err.str() );
      }
      delete nature_name;
    }
    delete nature_set;
  >>
;

concurrent_break_statement[IIRScram_Label *label] > [IIRScram_ConcurrentBreakStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *when_expression = NULL;
  >>
  concurrent_break_:BREAK
  <<
    $stmt = new IIRScram_ConcurrentBreakStatement();
    $stmt->set_label(label);
    copy_location(concurrent_break_,$stmt);
  >>
  { break_list[$stmt->get_concurrent_break_list()] }
  { sensitivity_clause[$stmt->get_sensitivity_list()] }
  { WHEN condition > [when_expression]
    <<$stmt->set_condition(when_expression);>>
  }
  SEMI_COLON
  <<dynamic_cast<IIRScram_ConcurrentBreakStatement *>($stmt)->_type_check();>>
;

set_of_simultaneous_statements[IIR_ArchitectureStatementList *stmts]:
  ( simultaneous_statement[$stmts] )*
;

simultaneous_statement[IIR_ArchitectureStatementList *stmts]:
  <<
    IIRScram_SimultaneousStatement   *new_stmt       = NULL;
    IIRScram_Label                   *label          = NULL;
  >>
  { stmt_label > [label] }
  simultaneous_stmt[label] > [new_stmt]
  <<$stmts->append(new_stmt);>>
;

simultaneous_stmt[IIRScram_Label *label] > [IIRScram_SimultaneousStatement *stmt]:
  simple_simultaneous_statement[label] > [$stmt]
| simultaneous_if_statement[label] > [$stmt]
| simultaneous_case_statement[label] > [$stmt]
| simultaneous_procedural_statement[label] > [$stmt]
| simultaneous_null_statement[label] > [$stmt]
;

simple_simultaneous_statement[IIRScram_Label *label] > [IIRScram_SimpleSimultaneousStatement *stmt]:
  <<
    $stmt                       = NULL;
    IIRScram *left_expression        = NULL;
    IIRScram *right_expression       = NULL;
    IIRScram *tolerance_expression   = NULL;
  >>
  simple_expression > [left_expression] double_:EQUAL_EQUAL simple_expression > [right_expression]
  { TOLERANCE expression > [tolerance_expression] }
  SEMI_COLON
  <<
    $stmt = new IIRScram_SimpleSimultaneousStatement();
    copy_location(double_,$stmt);
    $stmt->set_label(label);
    $stmt->set_left_expression(left_expression);
    $stmt->set_right_expression(right_expression);
    $stmt->set_tolerance_aspect(tolerance_expression);
    dynamic_cast<IIRScram_SimpleSimultaneousStatement *>($stmt)->_type_check();
  >>
;

simultaneous_if_statement[IIRScram_Label *label] > [IIRScram_SimultaneousIfStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *if_condition = NULL;
    IIRScram_SimpleName *end_name = NULL;
    IIRScram_SimultaneousElsif *simul_elsif = NULL;	
  >>
  if_:IF
  <<
    $stmt = new IIRScram_SimultaneousIfStatement();
    $stmt->set_label(label);
    copy_location(if_,$stmt);
  >>
  condition > [if_condition] <<$stmt->set_condition(if_condition);>>
  USE set_of_simultaneous_statements[$stmt->get_then_statement_list()]
  {
    (ELSIF)? simultaneous_elsif > [simul_elsif]
    <<$stmt->set_elsif(simul_elsif);>>
  }
  { else_:ELSE set_of_simultaneous_statements[$stmt->get_else_statement_list()] }
    END USE	
  { simple_name > [end_name] }
  SEMI_COLON
  <<dynamic_cast<IIRScram_SimultaneousIfStatement *>($stmt)->_type_check();>>
;

simultaneous_elsif > [IIRScram_SimultaneousElsif *stmt]:
  <<
    $stmt = NULL;
    IIRScram *cond = NULL;
    IIRScram_SimultaneousElsif* next_elsif = NULL;
  >>
  sim_elsif_:ELSIF
  <<
    $stmt = new IIRScram_SimultaneousElsif();
    copy_location(sim_elsif_,$stmt);
  >>
  condition > [cond]
  USE
  set_of_simultaneous_statements[$stmt->get_then_sequence_of_statements()]
  <<$stmt->set_condition(cond);>>
  {
  (ELSIF)? simultaneous_elsif > [next_elsif]
  <<$stmt->set_else_clause(next_elsif);>>
  }
;

simultaneous_case_statement[IIRScram_Label *label] > [IIRScram_SimultaneousStatement *stmt]:
  <<
    $stmt                                               = NULL;
    IIR                                 *selector       = NULL;
    IIRScram_CaseStatementAlternative        *alt            = NULL;
    IIRScram_SimpleName                      *end_name       = NULL;
  >>
  CASE expression > [selector] USE 
    ( WHEN choices > [alt] EQUAL_GREATER set_of_simultaneous_statements[NULL] )+
  END CASE 
  { simple_name > [end_name] }
  SEMI_COLON
;

simultaneous_procedural_statement[IIRScram_Label *label] > [IIRScram_SimultaneousStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram_SimpleName *end_name = NULL;
  >>
  PROCEDURAL {IS}
    (procedural_declarative_item[NULL])*
  BEGIN_
    sequence_of_statements[NULL]
  END PROCEDURAL { simple_name > [end_name] }
  SEMI_COLON
;

procedural_declarative_item[IIR_DeclarationList *decl_list]:
  subprogram[decl_list]
| type_declaration[decl_list]
| subtype_declaration[decl_list]
| constant_declaration[decl_list]
| variable_declaration[decl_list]
| alias_declaration[decl_list]
| attribute_declarative_item[decl_list]
| use_clause[decl_list]
| (GROUP IDENTIFIER COLON)? group_declaration[decl_list]
| group_template_declaration[decl_list]
;

simultaneous_null_statement[IIRScram_Label *label] > [IIRScram_SimultaneousStatement *stmt]:
  <<$stmt = NULL;>>
  NULL_ SEMI_COLON
;

break_list[IIR_BreakList *list] :
  <<IIRScram_BreakElement *element = NULL;>>
  break_element > [element] <<$list->append(element);>>
  ( COMMA break_element > [element] <<$list->append(element);>> )*
;

break_element > [IIRScram_BreakElement* b_element]:
  <<
    $b_element = NULL;
    IIRScram_Name* quantity_name = NULL;
    IIRScram_Name* selector_quantity_name = NULL;
    IIRScram *expr = NULL;
  >>
  { FOR complex_name > [selector_quantity_name] USE }
  complex_name > [quantity_name] EQUAL_GREATER expression > [expr]
  <<
    $b_element = new IIRScram_BreakElement();
    $b_element->set_quantity_name(quantity_name);
    $b_element->set_selector_quantity_name(selector_quantity_name);
    $b_element->set_expression(expr);
    $b_element->set_line_number(LT(1)->getLine());
  >>
 ;

break_statement [IIRScram_Label *label] > [IIRScram_BreakStatement *stmt]:
  <<
    $stmt = NULL;
    IIRScram *break_condition = NULL;
  >>
 break_:BREAK
 <<
   $stmt = new IIRScram_BreakStatement();
   copy_location(break_,$stmt);
 >>
  { break_list[$stmt->get_break_list()] }
  {
    WHEN condition > [break_condition]
    <<$stmt->set_condition(break_condition);>>
  }
  <<
    $stmt->set_label(label);
    dynamic_cast<IIRScram_BreakStatement *>($stmt)->_type_check();
  >>
;

/* **********************************************************************

Grammar Rules for VHDL-2001

********************************************************************** */

protected_type_declaration[IIRScram_TypeDeclaration *type_decl] > [IIRScram_TypeDefinition *retval]:
  <<
    $retval = NULL;
    IIRScram_Name *end_name = NULL;
  >>
  PROTECTED 
    ( protected_type_declarative_item[NULL] )*
  END PROTECTED 
  { simple_name > [end_name] }
;

protected_type_declarative_item[IIR_DeclarationList *decl_list]:
  subprogram_declaration[decl_list]
| attribute_specification[decl_list]
| use_clause[decl_list]
;

protected_type_body[IIRScram_TypeDeclaration *type_decl] > [IIRScram_TypeDefinition *retval]:
  <<
    $retval = NULL;
    IIRScram_Name *end_name = NULL;
  >>
  PROTECTED BODY
    ( protected_type_body_declarative_item[NULL] )*
  END PROTECTED BODY 
  { simple_name > [end_name] }
;

protected_type_body_declarative_item[IIR_DeclarationList *decl_list]:
  subprogram[decl_list]
| type_declaration[decl_list]
| subtype_declaration[decl_list]
| constant_declaration[decl_list]
| variable_declaration[decl_list]
| file_declaration[decl_list]
| alias_declaration[decl_list]
| attribute_declarative_item[decl_list]
| use_clause[decl_list]
| (GROUP IDENTIFIER COLON)? group_declaration[decl_list]
| group_template_declaration[decl_list]
;

}




